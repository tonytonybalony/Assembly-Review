你好！我是你的 **emu8086 組合語言家教**。

既然你已經學過計算機結構的基礎，今天我們進入 **【資料表示法、資料型態】**。這是所有程式設計的基石，在 C 語言中你只需要宣告 `int` 或 `char`，編譯器幫你處理好了一切；但在組合語言中，**你必須親自決定每一個位元組 (Byte) 該怎麼擺放**。

這單元是期中考「計算題」的大本營（特別是二補數、小端序、BCD 碼）。

---

### 1. 重點觀念介紹

#### **A. 資料長度 (Data Size)**
在 8086 (16-bit 架構) 中，我們最在乎三個單位：
1.  **Byte (位元組, 8-bit)**：對應 C 的 `char`。
    *   範圍：無號 0~255 (`00H`~`FFH`)，有號 -128~127。
2.  **Word (字組, 16-bit)**：對應 C 的 `short` 或 `int` (在 16-bit 系統中)。
    *   範圍：無號 0~65535 (`0000H`~`FFFFH`)。
3.  **Double Word (雙字組, 32-bit)**：對應 C 的 `long`。

#### **B. 小端序 (Little Endian)**
**這是期中考必考題！** (參考你的考題 Q17)
8086 採用小端序，口訣：**「低位組放低位址，高位組放高位址」**。
*   例子：數值 `1234H` 存入位址 `0100H`。
*   `34H` (低位) -> 存入 `0100H`
*   `12H` (高位) -> 存入 `0101H`

#### **C. 數值表示法**
1.  **二補數 (2's Complement)**：負數的表示法。(參考考題 Q10, Q18)
    *   計算：反相 + 1。
2.  **BCD 碼 (Binary Coded Decimal)**：用 4 個 bits 表示一個十進位數字 (0-9)。(參考考題 Q25)
    *   例如 `2025` 的 Packed BCD 是 `20 25H` (2 bytes)。
3.  **十六進位 (Hex)**：組語中習慣用 `H` 結尾，若開頭是字母 (A-F) 必須在前面加 `0` (例如 `0A0H`)，否則組譯器會以為是變數名稱。

---

### 2. 相關暫存器如何被用到

資料型態決定了你要用哪種暫存器：

*   **8-bit 資料**：使用 `AH`, `AL`, `BH`, `BL`, `CH`, `CL`, `DH`, `DL`。
    *   例如：`char c = 'A';` -> `MOV AL, 'A'`
*   **16-bit 資料**：使用 `AX`, `BX`, `CX`, `DX`, `SI`, `DI`, `SP`, `BP`。
    *   例如：`int i = 1000;` -> `MOV AX, 1000`

**分割觀念 (考題 Q9, Q12)：**
*   `AX` 是 16 bits。
*   `AH` 是 `AX` 的高 8 bits (High Byte)。
*   `AL` 是 `AX` 的低 8 bits (Low Byte)。
*   修改 `AL` **不會** 影響 `AH`，但會改變 `AX` 的值。

---

### 3. 詳細解釋相關指令 (資料定義偽指令)

這些不是 CPU 執行的指令，而是寫給**組譯器 (Assembler)** 看的，告訴它要在記憶體挖多少洞來放資料。

#### A. DB (Define Byte)
*   **語法**：`變數名 DB 值`
*   **C 對照**：`char var = 10;`
*   **用途**：定義 8-bit 資料。

#### B. DW (Define Word)
*   **語法**：`變數名 DW 值`
*   **C 對照**：`short var = 1000;`
*   **用途**：定義 16-bit 資料 (注意小端序儲存)。

#### C. DUP (Duplicate)
*   **語法**：`變數名 DB 數量 DUP(初始值)`
*   **C 對照**：`char arr[5] = {0};`
*   **用途**：定義陣列。

#### D. MOV (資料傳送)
*   **語法**：`MOV 目的, 來源`
*   **重點**：**兩邊的大小必須一致！** (8-bit 對 8-bit，16-bit 對 16-bit)。

---

### 4. & 5. emu8086 範例程式碼與邏輯對照

我們來模擬一些 C 語言的變數宣告與賦值。

**C 語言觀念：**
```c
char a = 0x12;          // 8-bit
short b = 0xABCD;       // 16-bit (負數)
char arr[3] = {1, 2, 3}; 
// 運算
short c = 0;
c = b;
```

**Assembly (emu8086)：**
```assembly
; 定義資料段 (Global Variables)
DATA SEGMENT
    val1    DB 12H          ; 定義 Byte: 12H
    val2    DW 0ABCDH       ; 定義 Word: ABCDH (注意前面補0)
    arr     DB 1, 2, 3      ; 定義 Byte 陣列
    arr2    DW 2 DUP(0)     ; 定義 Word 陣列，長度2，初始為0
    str     DB 'A'          ; 定義字元 (ASCII 41H)
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA ; 告訴組譯器段的關聯

START:
    ; --- 1. 初始化 DS (必做!) ---
    MOV AX, DATA
    MOV DS, AX      ; DS 指向 DATA 段

    ; --- 2. 8-bit 資料處理 ---
    MOV AL, val1    ; AL = 12H
    MOV AH, 0       ; 清空高位元
    ; 此時 AX = 0012H

    ; --- 3. 16-bit 資料處理與小端序觀察 ---
    MOV BX, val2    ; BX = ABCDH
    ; 在記憶體視窗中，val2 的位址如果是 0700:0001
    ; [0001] = CD (低位)
    ; [0002] = AB (高位)

    ; --- 4. 暫存器分割使用的陷阱 ---
    MOV CX, 0       ; CX = 0000H
    MOV CL, val1    ; CL = 12H -> CX = 0012H
    MOV CH, val1    ; CH = 12H -> CX = 1212H

    ; --- 5. 錯誤示範 (把這行註解拿掉會報錯) ---
    ; MOV AX, val1  ; 錯誤！AX是16位元，val1是8位元 -> Size Mismatch

    ; 結束程式
    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

假設 DATA 段從 `0700H:0000H` 開始。

| 變數/指令 | 記憶體位址 (Offset) | 記憶體內容 (Hex) | 暫存器變化 (Hex) | 說明 |
| :--- | :--- | :--- | :--- | :--- |
| `val1` | `0000` | **12** | - | 8-bit |
| `val2` | `0001` | **CD** | - | **小端序！** 低位 `CD` |
| | `0002` | **AB** | - | **小端序！** 高位 `AB` |
| `arr` | `0003` | **01** | - | arr[0] |
| `str` | `...` | **41** | - | ASCII 'A' |
| `MOV BX, val2` | - | - | **BX = ABCD** | 讀入時 CPU 會自動組合回來 |
| `MOV CH, val1` | - | - | **CH = 12** | 獨立修改高 8 bits |

---

### 7. 初學者在 emu8086 最常犯的錯誤

1.  **大小不合 (Operand Size Mismatch)**：
    *   ❌ `MOV AX, BL` (16 bit vs 8 bit)
    *   ❌ `MOV AL, 1000` (1000 超過 255)
    *   ✅ `MOV AX, BX` 或 `MOV AL, BL`
2.  **忘記 Hex 開頭的 0**：
    *   ❌ `MOV AX, FFH` (組譯器以為這是變數 FFH)
    *   ✅ `MOV AX, 0FFH` (這是數值)
3.  **小端序混淆**：
    *   手寫題目時，常把 `1234H` 填入記憶體順序寫成 `12`, `34`。
    *   正確應為 `34` (位址小), `12` (位址大)。
4.  **ASCII 與 數值混淆**：
    *   `MOV AL, 1` (數值 1)
    *   `MOV AL, '1'` (字元 '1'，ASCII 是 31H，即數值 49)

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目完全模仿你的期中考題型，請準備紙筆計算。

1.  **[二補數]** (模仿考題 Q10) 將十進位數 `-5` 表示為 8 位元的二補數形式 (Hex)。
2.  **[小端序]** (模仿考題 Q17) 將 32 位元數值 `1A2B3C4DH` 存入記憶體位址 `0100H`。請問 `0102H` 這個位址的內容是什麼？
3.  **[暫存器組合]** (模仿考題 Q12) 若 `BH = 30H`，`BL = 04H`，請問暫存器 `BX` 的完整十六進位值為何？這對應到 ASCII 字元是什麼？(提示: 查表或推算)
4.  **[記憶體空間]** `DW 10 DUP(?)` 這行指令會佔用多少 bytes 的記憶體空間？
5.  **[溢位判斷]** (模仿考題 Q18) 計算 8 位元二補數加法 `7F H + 01 H`，結果(Hex)為何？`OF` (Overflow Flag) 是 0 還是 1？
6.  **[BCD碼]** (模仿考題 Q25) 十進位數 `95` 的 Packed BCD 碼形式為何？(Hex表示)
7.  **[指令除錯]** 判斷指令 `MOV DS, 1234H` 是否合法？如果不合法，該如何修正？
8.  **[十六進位表示]** (模仿考題 Q11) 指令 `MOV AX, [0A0H]`，請問來源運算元是指「數值 0A0H」還是「位址 0A0H」？
9.  **[資料定義]** 若記憶體內容為 `12 34` (由低位址到高位址)，若我用 `MOV AX, [addr]` (Word存取) 讀出來的值是多少？
10. **[暫存器拆分]** 已知 `AX = 1234H`。執行 `ADD AL, 2` 後，`AH` 的值會變嗎？`AX` 的新值是多少？

---

### 9. 練習題詳解與推導 (一定要先自己算！)

**1. [二補數]**
*   推導：
    1.  取 5 的二進位：`0000 0101`
    2.  反相 (1變0, 0變1)：`1111 1010`
    3.  加 1：`1111 1011`
    4.  轉 Hex：`1111`=F, `1011`=B
*   答案：**FBH**

**2. [小端序]**
*   推導：數值 `1A 2B 3C 4D` (Hex)
    *   低位組 -> 低位址
    *   `0100H`: 4D
    *   `0101H`: 3C
    *   `0102H`: **2B**
    *   `0103H`: 1A
*   答案：**2BH**

**3. [暫存器組合]**
*   推導：BX = BH (高) + BL (低)
*   組合：**3004H**
*   (額外) 若看 ASCII，30H 是 '0'，04H 是 EOT (控制字元)。但如果是問 BX 作為一個數值，就是 3004H。

**4. [記憶體空間]**
*   推導：`DW` 是 Define Word (2 bytes)。`10 DUP` 代表重複 10 次。
*   計算：2 bytes * 10 = 20 bytes。
*   答案：**20 Bytes**

**5. [溢位判斷]**
*   推導：
    *   7F H = 0111 1111 (+127)
    *   01 H = 0000 0001 (+1)
    *   相加 = 1000 0000 (80H)
    *   在有號數系統，80H 是 -128。
    *   正 + 正 = 負 -> **溢位**。
*   答案：結果 **80H**，**OF = 1**。

**6. [BCD碼]**
*   推導：Packed BCD 用 4 bits 存一個位數。
    *   9 -> 1001
    *   5 -> 0101
*   答案：**95H** (1 byte)

**7. [指令除錯]**
*   推導：MOV 指令**不能**直接將「立即數」傳送給「段暫存器 (CS, DS, SS, ES)」。
*   答案：**不合法**。修正：
    ```assembly
    MOV AX, 1234H
    MOV DS, AX
    ```

**8. [十六進位表示]**
*   推導：有 `[ ]` 代表它是**記憶體位址**。
*   答案：**位址 0A0H** 內的內容。

**9. [資料定義]**
*   推導：記憶體 `12` (低位址), `34` (高位址)。
    *   Word 讀取時，低位址給 AL (低位)，高位址給 AH (高位)。
    *   AL = 12H, AH = 34H。
    *   AX = 3412H。
*   答案：**3412H**

**10. [暫存器拆分]**
*   推導：
    *   原 AX = 1234H -> AH = 12H, AL = 34H。
    *   `ADD AL, 2` -> 34H + 2H = 36H。
    *   進位不會跑到 AH (這是 8-bit 運算)。
    *   AH 保持不變。
*   答案：AH = **12H**，AX = **1236H**。

希望這份教學能幫你搞定「資料表示法」！如果有哪裡卡住，隨時問我。下一章我們會進入更刺激的指令週期！加油！
