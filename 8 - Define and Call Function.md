你好！我是你的 **emu8086 組合語言家教**。

我們剛結束了迴圈結構，現在要進入 **【流程控制 - 函式定義與呼叫】**。

這是一個巨大的分水嶺。期中考前的程式碼通常寫在一個巨大的 `START` 區塊裡（像 C 語言的 `main` 函式寫了幾百行）。現在我們要學習如何將程式模組化。

### 1. 重點觀念：CALL 與 JMP 的差別

在 C 語言中，你寫 `int result = add(a, b);`。這行程式碼做了兩件事：
1.  **跳去** `add` 函式執行。
2.  執行完後，**回來** 繼續執行下一行。

在組合語言中：
*   `JMP` (Jump) 是 **「單程票」**：跳過去就不回來了（除非你在那邊又寫一個 JMP 跳回來，但那樣很亂）。
*   `CALL` 是 **「來回票」**：跳過去之前，CPU 會先把你「現在的位址」存起來（存根），等函式執行完 `RET` (Return) 時，再拿出這個位址跳回來。

**核心機制：堆疊 (Stack)**
那張「存根」（Return Address）存在哪裡？就是 **堆疊 (Stack)**。這就是為什麼期中考一直在考 `SP` 和 `SS` 的原因。

---

### 2. 相關暫存器如何被用到

在這個單元，下列暫存器是主角：

*   **IP (Instruction Pointer)**：
    *   永遠指向「下一條要執行的指令」。
    *   **CALL 時**：CPU 會把 **「CALL 指令的下一行位址」** (Return Address) 壓入堆疊，然後將 IP 修改為函式的位址。
    *   **RET 時**：CPU 從堆疊彈出 (POP) 位址，填回 IP，程式就「回來」了。
*   **SP (Stack Pointer)**：
    *   **CALL 時**：`SP = SP - 2` (因為壓入了一個 16-bit 的位址)。
    *   **RET 時**：`SP = SP + 2` (因為彈出了一個位址)。
    *   **最常犯錯點**：如果在函式內亂 PUSH 卻沒 POP，`RET` 會拿到錯誤的位址，程式直接當機。
*   **AX, BX, CX, DX**：
    *   用來 **傳遞參數** (Pass Parameters) 或 **回傳值** (Return Value)。
    *   *註：下一章我們會學用堆疊傳參數，這章先用暫存器傳。*

---

### 3. 詳細解釋相關指令

#### A. PROC / ENDP (定義程序)
*   **語法**：
    ```assembly
    MyFunc PROC
        ; 程式碼
    MyFunc ENDP
    ```
*   **說明**：這是給組譯器看的偽指令 (Pseudo-op)，告訴它函式的範圍。

#### B. CALL (呼叫)
*   **語法**：`CALL MyFunc`
*   **動作**：
    1.  `PUSH IP` (將下一行指令的 Offset 存入堆疊)。
    2.  `JMP MyFunc` (跳去函式)。

#### C. RET (返回)
*   **語法**：`RET`
*   **動作**：
    1.  `POP IP` (從堆疊取出返回位址)。
    2.  程式跳回呼叫處的下一行。
*   **常見錯誤**：忘記寫 `RET`，程式會繼續往下跑，跑到記憶體的荒原。

---

### 4. & 5. 範例程式碼與 C 語言對照 (emu8086)

我們來寫一個簡單的 **「計算 AX 的絕對值」** 函式。

**C 語言：**
```c
void make_abs() {
    if (ax < 0) ax = -ax;
}

int main() {
    ax = -10;
    make_abs(); // 呼叫函式
    // 回來後 ax 應該是 10
    return 0;
}
```

**Assembly (emu8086)：**
```assembly
DATA SEGMENT
    ; 資料段 (本例未用到)
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA

START:              ; --- 主程式 (Main) 開始 ---
    MOV AX, -10     ; 1. 準備參數 (FFF6H)
    
    CALL ABS_FUNC   ; 2. 呼叫函式
                    ;    (此時 SP-2, Stack存入下一行位址)
    
    ; 3. 函式返回後，從這裡繼續執行
    ; 此時 AX 應該變成 10 (000AH)
    
    MOV AH, 4CH
    INT 21H         ; 結束程式 (一定要在這裡結束，不然會掉進函式裡!)

; --- 函式定義區 ---
ABS_FUNC PROC
    CMP AX, 0       ; 比較 AX 與 0
    JGE DONE        ; 如果 AX >= 0，直接跳去結束
    NEG AX          ; 如果 AX < 0，取補數 (變成正數)
DONE:
    RET             ; **關鍵！** POP IP，返回主程式
ABS_FUNC ENDP

CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

假設 `CALL ABS_FUNC` 這行指令位於 Offset `0005H`，長度 3 bytes。
下一行指令（`MOV AH, 4CH`）位於 `0008H`。
`ABS_FUNC` 位於 `0010H`。
初始 `SP = FFFEH`。

| 步驟 | 指令 | IP (執行前) | SP 變化 | 堆疊內容 (SS:[SP]) | 說明 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | `MOV AX, -10` | 0000H | FFFEH | (無關) | AX = FFF6H |
| 2 | `CALL ABS_FUNC` | **0005H** | **FFFCH** (-2) | **0008H** | 1. 壓入返回位址 (0008H)<br>2. IP 跳至 0010H |
| 3 | `CMP AX, 0` | 0010H | FFFCH | 0008H | 在函式內執行 |
| ... | (中間邏輯) | ... | ... | ... | AX 變為 000AH |
| 4 | `RET` | **00xxH** | **FFFEH** (+2) | (已彈出) | 1. 取出 0008H 給 IP<br>2. SP 恢復原狀 |
| 5 | `MOV AH, 4CH` | **0008H** | FFFEH | (無關) | 回到主程式繼續 |

---

### 7. 初學者在 emu8086 最常犯的錯誤

1.  **程式流程「掉進」函式 (Fall-through)**：
    *   **錯誤寫法**：
        ```assembly
        START:
            MOV AX, 10
            CALL MY_FUNC
            ; 這裡忘了寫結束程式的中斷 (INT 21H)
        MY_FUNC PROC
            ...
        ```
    *   **後果**：主程式執行完 `CALL` 回來後，繼續往下走，直接「撞進」 `MY_FUNC` 再執行一次。
    *   **修正**：主程式結束處必須有 `MOV AH, 4CH / INT 21H` 擋住。
2.  **堆疊不平衡 (Stack Imbalance)**：
    *   **錯誤**：在函式內 `PUSH AX` 保護暫存器，但 `RET` 前忘了 `POP AX`。
    *   **後果**：`RET` 指令會把堆疊頂端的 `AX` 值當成 `IP` 返回位址 -> 程式跳去奇怪的地方 -> 當機。
3.  **定義巢狀函式**：
    *   emu8086 不支援在 `PROC` 裡面再寫一個 `PROC`。請把函式分開寫。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目是為了讓你搞懂 **Stack Frame** 的基礎以及 `CALL/RET` 的物理動作。

**題目：**

1.  **[指令行為]** 執行 `CALL 1000H` 指令時，`IP` 暫存器會被存入哪裡？`SP` 暫存器會增加還是減少？
2.  **[位址計算]** 假設 `SP = 0100H`。執行 `CALL MyProc` (為 Near Call) 後，新的 `SP` 值是多少？
3.  **[堆疊內容]** 承上題，如果 `CALL` 指令的下一條指令位址是 `0020H`，那麼實體位址 `SS:[New_SP]` 的內容是多少？
4.  **[RET 原理]** `RET` 指令其實可以用哪兩個指令組合來模擬？(提示：取出位址、跳轉)。
5.  **[除錯 - 堆疊平衡]**
    ```assembly
    FUNC PROC
        PUSH AX
        MOV AX, 0
        RET      ; <--- 這裡會發生什麼事？
    FUNC ENDP
    ```
6.  **[遞迴概念]** 如果一個函式自己呼叫自己 (Recursive Call)，且沒有終止條件，最後會發生什麼錯誤？(提示：與 SP 有關)。
7.  **[參數傳遞]** 在不使用堆疊傳遞參數的情況下，我們通常預設用哪個暫存器來存放函式的**回傳值** (Return Value)？
8.  **[段位址]** 如果是 `FAR CALL` (呼叫不同 Code Segment 的函式)，堆疊裡除了存 `IP`，還需要存哪個暫存器？
9.  **[流程控制]**
    ```assembly
    MOV AX, 1
    CALL ADD_ONE
    ADD_ONE PROC
        ADD AX, 1
        RET
    ADD_ONE ENDP
    ```
    這段程式碼執行時會出現什麼邏輯問題？(注意 `CALL` 之後沒有結束主程式)。
10. **[實體位址計算]** (模仿考題 Q16, Q23)
    已知 `SS = 2000H`, `SP = 0010H`。程式執行 `CALL` 指令（下一行位址為 `0150H`）。請計算 `CALL` 完成後，存放返回位址的記憶體**實體位址**，以及該記憶體內的**值**。

---

### 9. 解題思路與推導 (做完再看！)

**1. [指令行為]**
*   IP 會被存入 **堆疊 (Stack)**。
*   因為堆疊是向下生長 (High -> Low)，所以 SP 會 **減少**。

**2. [位址計算]**
*   8086 的 Near Call 只存 Offset IP (16-bit = 2 bytes)。
*   SP = 0100H - 2 = **00FEH**。

**3. [堆疊內容]**
*   堆疊頂端存的就是「返回位址」。
*   內容就是 CALL 下一行的位址：**0020H**。

**4. [RET 原理]**
*   RET 的動作是「把堆疊頂端的值彈出給 IP」。
*   等同於：`POP IP` (注意：8086 指令集不允許直接寫 `POP IP`，但邏輯上是這樣)。實際模擬是 `POP temp` + `JMP temp`。

**5. [除錯 - 堆疊平衡]**
*   **災難發生**。
*   PUSH AX 把 AX 的值壓在返回位址之上。
*   RET 執行時，會把 AX 的值當作 IP 跳過去。
*   程式會亂跳 (Crash)。

**6. [遞迴概念]**
*   每次 CALL 都會 PUSH 返回位址，SP 減 2。
*   沒有終止 -> 無限 PUSH。
*   SP 最終會減到 0，然後 wrap around 覆蓋掉有用的資料，或觸發 **Stack Overflow**。

**7. [參數傳遞]**
*   慣例 (Convention) 上，使用 **AX** 存放回傳值。

**8. [段位址]**
*   Far Call 需要換 Segment。
*   所以必須存 **CS (Code Segment)** 和 IP。
*   堆疊會壓入 4 bytes (CS + IP)。

**9. [流程控制]**
*   **Fall-through 問題**。
*   主程式 `CALL ADD_ONE` 回來後，沒有停止。
*   CPU 會繼續往下執行下一行記憶體，也就是 `ADD_ONE PROC` 的內容。
*   結果：AX 會被加 1 (CALL內)，回來後又被加 1 (撞進去)，變成 3 (預期是 2)，然後遇到 `RET` 但堆疊是空的，程式崩潰。

**10. [實體位址計算]**
*   **步驟一：找堆疊頂端**
    *   CALL 壓入 2 bytes -> SP 變為 `0010H - 2 = 000EH`。
*   **步驟二：算實體位址**
    *   Physical Address = SS * 16 + SP
    *   = 20000H + 000EH = **2000EH**。
*   **步驟三：找內容**
    *   內容是返回位址 (Next IP) -> **0150H**。

---
希望這章能讓你理解函式呼叫的「來回票」機制！
下一章我們要挑戰 **第 9 單元：函式參數傳遞**，到時候會用到 `BP` 來存取堆疊裡的參數，那是組合語言最難也最精華的部分，請先把這章的 `SP` 變化練熟喔！