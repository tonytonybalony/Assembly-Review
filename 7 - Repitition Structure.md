你好！我是你的 **emu8086 組合語言家教**。

我們現在進入第 7 單元：**【流程控制 - 重覆結構】**（Loops）。

既然你已經學過了 **循序結構**（程式往下跑）和 **選擇結構**（遇到岔路跳轉），重覆結構其實就是這兩者的結合：**「做完事情後，跳回去上面再做一次，直到條件不滿足為止」**。

在 C 語言中，你習慣用 `for`, `while`, `do-while`。在 8086 組合語言中，最核心的指令是 `LOOP`，但它背後其實隱藏著對 **CX 暫存器** 的依賴。

---

### 1. 重點觀念：重覆結構的底層邏輯

在組合語言中，迴圈通常分為兩類：
1.  **計數迴圈 (Counter-Controlled)**：像 C 的 `for(i=0; i<10; i++)`。這在 8086 中有專門的硬體指令 `LOOP` 支援。
2.  **條件迴圈 (Condition-Controlled)**：像 C 的 `while(a < b)`。這需要用 `CMP` 搭配 `JMP` (跳躍指令) 來實作。

**期中考後的重點變化：**
期中考前我們關注單行指令的運算與定址；現在重點在於**指令如何改變 IP (Instruction Pointer) 來形成「圈圈」**，以及**陣列存取**（通常迴圈都是為了處理陣列）。

---

### 2. 相關暫存器如何被用到

*   **CX (Count Register)**：**迴圈的主角！**
    *   指令 `LOOP` 會自動將 `CX` 減 1，並檢查它是否為 0。
    *   如果你要跑 10 次迴圈，必須先將 `CX` 設為 10。
*   **SI / DI (Source/Destination Index)**：
    *   在迴圈中通常用來當作「陣列的索引」（像是 C 語言的 `arr[i]` 的 `i`）。
    *   每次迴圈結束前，手動 `ADD SI, 2` (如果是 word) 或 `INC SI` (如果是 byte) 來指向下一個元素。
*   **IP (Instruction Pointer)**：
    *   決定現在執行哪一行，迴圈的本質就是把 IP 修改回前面的記憶體位址。
*   **FLAGS**：
    *   `LOOP` 指令本身**不影響**旗標（這是重要考點！）。
    *   但如果是用 `DEC CX` + `JNZ` 自己寫的迴圈，`DEC` 會影響 ZF。

---

### 3. 詳細解釋相關指令

#### A. LOOP (迴圈指令)
*   **語法**：`LOOP Label`
*   **邏輯**：
    1.  `CX = CX - 1` (自動遞減，不影響旗標)
    2.  檢查 `CX` 是否不等於 0。
    3.  若 `CX != 0`，跳轉至 `Label` (修改 IP)。
    4.  若 `CX == 0`，往下執行下一行。
*   **常見錯誤**：初始 `CX=0`。因為先減後判斷，0 減 1 變成 FFFFH (65535)，會變成無窮迴圈（直到跑完 6萬多次）。

#### B. JCXZ (Jump if CX is Zero)
*   **語法**：`JCXZ Label`
*   **用途**：防止迴圈執行前 `CX` 就已經是 0 的保護機制（類似 `while` 迴圈一開始就檢查）。

#### C. INC / ADD (指標移動)
*   **語法**：`INC SI` 或 `ADD SI, 2`
*   **用途**：移動記憶體指標。
*   **注意**：存取 `DW` (16-bit) 陣列時，指標要 `+2`；存取 `DB` (8-bit) 時，指標要 `+1`。

---

### 4. & 5. 範例程式碼與 C 語言對照 (emu8086)

#### 範例一：基本的計數迴圈 (計算 1+2+...+10)

**C 語言：**
```c
int sum = 0;
for (int i = 10; i > 0; i--) {
    sum = sum + i;
}
```

**Assembly (emu8086)：**
```assembly
DATA SEGMENT
    sum DW 0
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX

    MOV CX, 10      ; 初始化計數器 (i = 10)
    MOV AX, 0       ; 初始化累加器 (sum = 0)

AGAIN:              ; --- 迴圈標籤開始 ---
    ADD AX, CX      ; AX = AX + CX
    
    ; LOOP 指令做兩件事：
    ; 1. CX = CX - 1
    ; 2. If CX != 0 goto AGAIN
    LOOP AGAIN      ; --- 迴圈結束 ---

    MOV sum, AX     ; 存回結果 (55 = 0037H)

    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

#### 範例二：陣列遍歷 (Array Iteration)

**C 語言：**
```c
short arr[] = {10, 20, 30, 40, 50}; // 16-bit numbers
int sum = 0;
for (int i = 0; i < 5; i++) {
    sum += arr[i];
}
```

**Assembly (emu8086)：**
```assembly
DATA SEGMENT
    arr DW 10, 20, 30, 40, 50 ; 定義 Word 陣列
    sum DW ?
DATA ENDS

CODE SEGMENT
START:
    MOV AX, DATA
    MOV DS, AX

    MOV CX, 5       ; 陣列長度
    LEA SI, arr     ; SI 指向陣列開頭 (Load Effective Address)
    MOV AX, 0       ; 清空 sum

NEXT_ELEMENT:
    ADD AX, [SI]    ; 加總目前的元素 arr[i]
    ADD SI, 2       ; 指標移動 2 bytes (因為是 DW)
    LOOP NEXT_ELEMENT

    MOV sum, AX     ; 結果應為 150 (0096H)

    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

我們針對**範例一 (1+2+3)** 做一個簡單的 Trace，假設 CX 初始為 3：

| 步驟 | 指令 | CX 值 (變動後) | AX 值 (累加) | 說明 |
| :--- | :--- | :--- | :--- | :--- |
| Init | `MOV CX, 3` | 0003H | 0000H | 準備開始 |
| Loop 1 | `ADD AX, CX` | 0003H | **0003H** | 加 3 |
| | `LOOP AGAIN` | **0002H** | 0003H | CX減1，不為0，跳回 |
| Loop 2 | `ADD AX, CX` | 0002H | **0005H** (3+2) | 加 2 |
| | `LOOP AGAIN` | **0001H** | 0005H | CX減1，不為0，跳回 |
| Loop 3 | `ADD AX, CX` | 0001H | **0006H** (5+1) | 加 1 |
| | `LOOP AGAIN` | **0000H** | 0006H | CX減1，**為0，不跳** |
| End | (Next Line) | 0000H | 0006H | 迴圈結束 |

---

### 7. 初學者最常犯的錯誤

1.  **CX 初始值為 0**：
    *   如果你寫 `MOV CX, 0` 然後執行 `LOOP`，它會先減 1 變成 `FFFFH` (-1)，導致它非 0，然後繼續跑... 總共跑 65536 次。這是經典的「無窮迴圈」錯誤（雖然它最終會停，但很久）。
2.  **陣列指標移動量錯誤**：
    *   `DB` (Byte)陣列要 `INC SI` (+1)。
    *   `DW` (Word)陣列要 `ADD SI, 2` (+2)。
    *   寫錯的話會讀到記憶體的一半，資料全錯。
3.  **迴圈內修改了 CX**：
    *   如果你在迴圈裡面寫了 `MOV CX, ...` 或 `ADD CX, ...`，會破壞迴圈的計數器，導致提早結束或永遠跑不完。
    *   *修正：* 如果迴圈內需要用到計數功能，請用其他暫存器 (BX, DX) 或推入堆疊 (PUSH CX)。
4.  **LOOP 距離太遠**：
    *   `LOOP` 指令是 Short Jump，只能跳 -128 ~ +127 bytes。如果迴圈內容太長，編譯器會報錯。
    *   *修正：* 改用 `DEC CX` + `JNZ Label` (JNZ 可以搭配長跳躍)。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目模仿了你的期中考題型，結合了迴圈特性與定址法計算。

**題目：**

1.  **[指令行為]** 執行 `LOOP Label` 指令時，CPU 內部會依序執行哪兩個動作？(請精確描述對暫存器的影響)
2.  **[迴圈次數]** 若 `CX = 0000H`，執行到 `LOOP Start` 指令，請問這個迴圈還會執行幾次？
3.  **[陣列定址]** 有一個陣列宣告為 `ARRAY DW 10H, 20H, 30H`。若 `SI` 指向陣列開頭，執行兩次 `ADD SI, 2` 後，指令 `MOV AX, [SI]` 會讀到什麼值？
4.  **[指令轉換]** 請用 `DEC` 和 `JNZ` 兩個指令，組合出等同於 `LOOP Target` 的功能。(寫出 Assembly 代碼)
5.  **[旗標影響]** `LOOP` 指令執行後，是否會影響 `ZF` (Zero Flag)？為什麼？
6.  **[實體位址]** (模仿考題 Q23)
    指令 `LOOP F0H` (機器碼 E2 F0) 位於位址 `0100H`，長度 2 bytes。
    (1) 執行該指令時，CPU 先將 IP 更新為多少？
    (2) 若 CX 減 1 後不為 0，且 F0H 代表 -16 (十進位)，下一個 IP 位址是多少？
7.  **[巢狀迴圈]** 如果有雙層迴圈，外層跑 10 次，內層跑 5 次。請問進入內層迴圈前，應該如何處理外層的 `CX`？(提示：堆疊)
8.  **[字串處理]** 8086 有一個 `REP` 前綴指令，通常搭配 `MOVSB` 使用。請問 `REP` 是依據哪個暫存器來決定重複次數？
9.  **[邏輯追蹤]**
    ```assembly
    MOV CX, 3
    MOV AX, 0
    L1: ADD AX, 1
        LOOP L1
    ```
    執行完後，AX = ?
10. **[除錯題]** 想要計算 1 到 100 的總和，程式碼如下，請指出哪裡有錯：
    ```assembly
    MOV CX, 100
    MOV AX, 0
    START:
        ADD AX, CX
        INC CX      ; <--- 這裡
    LOOP START
    ```

---

### 9. 練習題詳解與推導

**請務必先自己試算，再看這裡的推導！**

1.  **[指令行為]**
    *   動作 1：`CX = CX - 1`。
    *   動作 2：檢查若 `CX != 0`，則 `IP = IP + 位移量` (跳轉)；否則往下執行。

2.  **[迴圈次數]**
    *   推導：`LOOP` 先減後判斷。
    *   `0 - 1 = FFFFH` (65535)。
    *   因為 `FFFFH != 0`，所以會跳回去。
    *   答案：**65536 次** (會跑非常久)。

3.  **[陣列定址]**
    *   推導：`DW` (Define Word) 每個元素佔 2 bytes。
    *   `ARRAY` (idx 0), `ARRAY+2` (idx 1), `ARRAY+4` (idx 2)。
    *   執行兩次 `ADD SI, 2` -> SI 增加了 4。
    *   指向第三個元素。
    *   答案：**30H**。

4.  **[指令轉換]**
    ```assembly
    DEC CX          ; CX 減 1，且會影響 ZF
    JNZ Target      ; 若結果不為 0 (ZF=0)，則跳轉
    ```
    *(註：標準 LOOP 指令不影響旗標，但拆開寫會影響旗標，這是細微差別，但邏輯功能一致)*

5.  **[旗標影響]**
    *   答案：**不會**。
    *   理由：`LOOP` 指令的設計是「內部」檢查 CX，不會更新 FLAGS 暫存器（不同於 DEC 或 SUB）。

6.  **[實體位址]**
    *   (1) 讀取指令後，IP 指向下一條：`0100H + 2 = 0102H`。
    *   (2) `LOOP` 觸發跳轉，IP + 偏移量。
    *   F0H 是 8-bit 二補數，代表 -16 (十進位)。
    *   `0102H - 10H (16) = 00F2H`。
    *   答案：(1) **0102H** (2) **00F2H**。

7.  **[巢狀迴圈]**
    *   推導：內層迴圈也需要用 CX，會覆蓋外層的計數。
    *   作法：進入內層前 `PUSH CX` (保存外層計數)，內層結束後 `POP CX` (恢復外層計數)，再執行外層的 `LOOP`。

8.  **[字串處理]**
    *   答案：**CX** 暫存器。
    *   `REP` (Repeat) 會重複執行字串指令，直到 `CX=0`。

9.  **[邏輯追蹤]**
    *   迴圈跑 3 次。
    *   每次 `ADD AX, 1`。
    *   0 + 1 + 1 + 1 = 3。
    *   答案：**3**。

10. **[除錯題]**
    *   錯誤點：`INC CX`。
    *   推導：
        1.  `LOOP` 指令會自動 `DEC CX`。
        2.  如果你在迴圈內 `INC CX`，剛好抵銷。
        3.  `CX` 永遠維持 100，永遠不會變成 0。
    *   後果：**無窮迴圈**。

希望這個單元能幫你搞定 **迴圈結構**！接下來就是函式呼叫了，那裡會更頻繁用到堆疊，請把 `PUSH/POP` 和 `CX` 的觀念先練熟喔！加油！