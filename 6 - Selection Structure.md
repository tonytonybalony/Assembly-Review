你好！我是你的 **emu8086 組合語言家教**。

恭喜你順利度過期中考（假設你已經複習完循序結構）！現在我們要進入 **流程控制 - 選擇結構**。

在 C 語言中，這就是你熟悉的 `if`, `else`, `switch`, `case`。
但在組合語言中，沒有大括號 `{}`，也沒有 `if` 這種關鍵字。CPU 只有能力做兩件事來達成選擇：
1.  **比較 (Compare)**：拿兩個數相減，看結果的狀態（旗標）。
2.  **跳轉 (Jump)**：根據旗標的狀態，決定要不要修改 IP (Instruction Pointer) 去執行別處的程式碼。

---

### 1. 重點觀念：選擇結構的「兩步法」

在 C 語言寫 `if (a > b)` 時，編譯器在底層會將其翻譯成：
1.  **CMP a, b** (做減法運算 a - b，但不存結果，只更新旗標)
2.  **JG Label** (Jump if Greater，如果前者大於後者，就跳去執行某段程式)

**關鍵思維轉換**：
在 C 語言，我們習慣寫「條件成立時做什麼」：
```c
if (AX == BX) {
    AX = 1;
}
AX = 0;
```
在組合語言，為了讓程式碼順暢，我們常寫**「反向邏輯」**（如果條件**不成立**，就跳過）：
```assembly
    CMP AX, BX
    JNE SKIP_WORK  ; 如果 不相等 (Not Equal)，就跳過下面那行
    MOV AX, 1      ; 只有相等才會執行這行
SKIP_WORK:
    MOV AX, 0      ; 繼續執行
```

---

### 2. 相關暫存器如何被用到

*   **FLAGS (旗標暫存器)**：這是選擇結構的核心。
    *   **ZF (Zero Flag)**：`CMP A, B` 後，若 `A == B`，相減為 0，則 **ZF=1**。
    *   **SF (Sign Flag)**：用來判斷正負，輔助有號數比較。
    *   **CF (Carry Flag)**：**無號數** (Unsigned) 比較時，若 `A < B`，`A - B` 會發生借位，**CF=1**。
    *   **OF (Overflow Flag)**：**有號數** (Signed) 比較時，用來判斷是否發生溢位導致大小判斷錯誤。
*   **IP (Instruction Pointer)**：
    *   當跳轉條件成立時，CPU 會把目標位址（標籤的 Offset）填入 IP，下一條指令就從那裡開始執行。

---

### 3. 詳細解釋相關指令

#### A. CMP (Compare)
*   **語法**：`CMP 目的, 來源`
*   **邏輯**：執行 `目的 - 來源`，**不改變目的運算元的值**，只改變 **FLAGS**。
*   **用途**：為跳轉指令鋪路。

#### B. JMP (Unconditional Jump)
*   **語法**：`JMP Label`
*   **邏輯**：無條件強制跳到 Label。
*   **用途**：常用於 `else` 區塊結束後，跳過 `else` 的部分，或用於無窮迴圈。

#### C. 條件跳轉指令 (Conditional Jumps)
這是初學者最容易搞混的地方，**有號數**與**無號數**要用不同的指令！

| 比較意義 | 無號數指令 (Unsigned) | 有號數指令 (Signed) | 旗標判斷原理 (進階) |
| :--- | :--- | :--- | :--- |
| **相等** (==) | `JE` / `JZ` | `JE` / `JZ` | ZF = 1 |
| **不相等** (!=) | `JNE` / `JNZ` | `JNE` / `JNZ` | ZF = 0 |
| **大於** (>) | `JA` (Above) | `JG` (Greater) | CF=0 & ZF=0 (無) vs SF=OF & ZF=0 (有) |
| **小於** (<) | `JB` (Below) | `JL` (Less) | CF=1 (無) vs SF≠OF (有) |
| **大於等於** (>=) | `JAE` | `JGE` | |
| **小於等於** (<=) | `JBE` | `JLE` | |

> **記憶口訣**：
> *   無號數看高低 (Above/Below) -> 比如記憶體位址高低。
> *   有號數看大小 (Greater/Less) -> 比如數學運算正負。

---

### 4. & 5. 範例程式碼與 C 語言對照 (emu8086)

#### 範例一：基本的 If-Else
**C 語言：**
```c
int ax = 10;
int bx = 20;
if (ax >= bx) {
    ax = ax - bx;
} else {
    ax = ax + bx;
}
```

**Assembly (emu8086)：**
```assembly
DATA SEGMENT
    valA DW 10
    valB DW 20
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    
    MOV AX, valA    ; AX = 10
    MOV BX, valB    ; BX = 20
    
    ; --- 選擇結構開始 ---
    CMP AX, BX      ; 比較 AX - BX (10 - 20)
    
    ; 我們用反向思考：如果 AX < BX (if條件不成立)，就跳去 ELSE
    ; 因為是單純整數，假設是有號數 (Signed)
    JL ELSE_BLOCK   ; JL (Jump if Less), 若 AX < BX 跳轉
    
    ; -- IF 區塊 (成立時執行) --
    SUB AX, BX      ; AX = AX - BX
    JMP EXIT_IF     ; **重要！** 做完 IF 必須跳過 ELSE 區塊
    
ELSE_BLOCK:
    ; -- ELSE 區塊 (不成立時執行) --
    ADD AX, BX      ; AX = AX + BX

EXIT_IF:
    ; 程式繼續...
    MOV valA, AX    ; 存回結果

    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

我們針對上面的範例進行推導：

1.  **初始**：`AX = 000AH` (10), `BX = 0014H` (20)。
2.  **指令 `CMP AX, BX`**：
    *   執行 `10 - 20 = -10` (F6H)。
    *   結果不為 0 -> **ZF = 0**。
    *   結果為負 -> **SF = 1**。
    *   沒有溢位 (正-正=負，合理) -> **OF = 0**。
3.  **指令 `JL ELSE_BLOCK`**：
    *   `JL` 檢查條件：`SF ≠ OF` (1 ≠ 0)，條件成立。
    *   **動作**：IP 改變，指向 `ELSE_BLOCK` 標籤的位址。
4.  **跳轉後**：
    *   跳過 `SUB` 指令。
    *   執行 `ADD AX, BX` -> 10 + 20 = 30。
    *   `AX` 最終變為 `001EH`。

---

### 7. 初學者最常犯的錯誤

1.  **混淆有號與無號跳轉 (JA vs JG)**：
    *   例子：比較 `FFH` (-1) 和 `00H` (0)。
    *   用 `JG` (有號)：-1 < 0，不跳。
    *   用 `JA` (無號)：255 > 0，會跳！
    *   **修正**：確認變數定義是 `int` (Signed) 還是 `unsigned int`。
2.  **忘記寫 JMP 跳過 Else**：
    *   執行完 IF 區塊後，如果沒有 `JMP EXIT_IF`，CPU 會繼續往下執行 ELSE 區塊，導致兩個區塊都跑了一遍，邏輯全錯。
3.  **CMP 的順序搞反**：
    *   `CMP AX, BX` 後接 `JG`，意思是 `if (AX > BX)`。
    *   如果寫成 `CMP BX, AX`，`JG` 就變成 `if (BX > AX)`。
4.  **短程跳轉 (Short Jump) 超出範圍**：
    *   條件跳轉 (如 JZ, JNE) 在 8086 中通常只能跳 -128 ~ +127 bytes 的距離。如果程式碼太長，組譯器會報錯。
    *   解決：用反向條件跳轉搭配 `JMP` (JMP 可跳較遠)。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目模仿了你的期中考題型，加入了選擇結構的特性（計算位址偏移量、旗標邏輯）。

**題目：**

1.  **[指令邏輯]** 若 `AX = 1000H`, `BX = 2000H`，執行 `CMP AX, BX` 後，旗標 `ZF` 和 `CF` (視為無號數借位) 分別是多少？
2.  **[跳轉判斷]** 承上題，若緊接著執行 `JA Label1`，請問會不會跳轉？為什麼？
3.  **[跳轉判斷 - 有號數]** 若 `AL = 80H` (-128), `BL = 01H` (+1)。執行 `CMP AL, BL` 後，`JG Label2` 會不會跳轉？(請推導 `80H - 01H` 的旗標變化)
4.  **[位址計算 - 相對定址]** (模仿考題 Q23)
    指令 `JNZ 05H` 位於記憶體位址 `0100H` (指令長度 2 bytes)。
    若條件成立，下一條要執行的指令實體位址是多少？（提示：IP 先指向下條指令，再加偏移量）
5.  **[C 轉 Assembly]** 請將 C 語言 `if (CX == 0) CX = 1;` 翻譯成組合語言 (使用 `CMP`, `JZ` 或 `JNZ` 搭配標籤)。
6.  **[旗標特性]** 執行 `OR AX, AX` 指令通常用來檢查什麼？(提示：觀察 ZF 和 SF)。這可以取代 `CMP AX, 0` 嗎？
7.  **[指令選擇]** 你想要判斷「AL 是否為大寫字母 'A' (41H) 到 'Z' (5AH) 之間」，你會使用 `JA/JB` 還是 `JG/JL`？為什麼？
8.  **[堆疊與流程]** 在 `CALL` 函式之前，通常會 `PUSH` 參數。如果在 `IF` 結構內 `PUSH` 了資料，但在 `ELSE` 結構沒 `PUSH`，最後統一 `POP`，會發生什麼嚴重後果？
9.  **[二補數與跳轉]** (模仿考題 Q18)
    計算 8 位元比較：`CMP 11110000b, 00000001b` (F0 - 01)。
    請判斷 `SF` 和 `OF` 的值，並說明 `JL` (Jump Less) 是否會動作？
10. **[實體位址 - 負偏移]** (進階計算)
    目前 `IP = 0200H`，執行一條 `JMP SHORT F0H` (F0H 為 -16 的補數)。
    假設 JMP 指令本身長度 2 bytes。請問跳轉後的 `IP` 是多少？

---

### 9. 練習題詳解與推導

**請務必先自己試算，再看這裡的推導！**

1.  **[指令邏輯]**
    *   推導：1000H - 2000H，不夠減，需借位。
    *   結果不為 0 -> **ZF=0**。
    *   發生借位 -> **CF=1**。

2.  **[跳轉判斷]**
    *   指令：`JA` (Jump if Above, 無號數大於)。
    *   邏輯：檢查 `CF=0` 且 `ZF=0`。
    *   現況：`CF=1` (表示 A < B)。
    *   結果：**不會跳轉**。

3.  **[跳轉判斷 - 有號數]**
    *   推導：`80H (-128) - 01H (1) = 7FH (+127)`。
    *   旗標：
        *   正數減正數變成正數 (邏輯上 -128 - 1 應該是 -129，溢位了!)
        *   結果 7F (正) -> **SF=0**。
        *   有號數溢位 (-128 - 1 超出範圍) -> **OF=1**。
    *   `JG` 條件：`SF == OF` 且 `ZF=0`。
    *   現況：0 ≠ 1。
    *   結果：**不會跳轉** (邏輯正確：-128 並沒有大於 1)。

4.  **[位址計算 - 相對定址]**
    *   JNZ 指令在 `0100H`，長度 2 bytes。
    *   讀取指令後，`IP` 自動加 2 -> `0102H`。
    *   條件成立，IP + 偏移量 = `0102H + 05H`。
    *   結果：**0107H**。

5.  **[C 轉 Assembly]**
    ```assembly
        CMP CX, 0
        JNZ SKIP    ; 如果不是0，跳過
        MOV CX, 1
    SKIP:
    ```
    (或者用 `JZ` 跳去執行的區塊，但反向邏輯較簡潔)

6.  **[旗標特性]**
    *   `OR` 運算會清除 CF, OF，並根據結果設定 ZF, SF。
    *   `OR AX, AX` 不改變 AX 的值，但若 AX=0，則 ZF=1；若 AX<0，則 SF=1。
    *   **可以取代 `CMP AX, 0`**，且指令長度通常更短、執行更快。

7.  **[指令選擇]**
    *   ASCII 碼 'A' (41H) ~ 'Z' (5A) 都是正整數，且不涉及負數邏輯。
    *   雖然 `JG/JL` 也可以用（因為 0-127 範圍內有號/無號行為一致），但標準做法是視為「字元編碼」(無號數)。
    *   答案：**JA/JB** (Unsigned)。

8.  **[堆疊與流程]**
    *   後果：**堆疊不平衡 (Stack Imbalance)**。
    *   若走 IF 路徑，PUSH 了一次；走 ELSE 路徑沒 PUSH。
    *   後面統一 POP 時，如果剛才走 ELSE，會 POP 出錯誤的資料（或者是回傳位址），導致程式崩潰或 `RET` 到錯誤的地方。

9.  **[二補數與跳轉]**
    *   算式：`F0H (-16) - 01H (1) = EFH (-17)`。
    *   無溢位 (負 - 正 = 負，在此範圍內合理)。
    *   結果 EFH (負) -> **SF=1**。
    *   無溢位 -> **OF=0**。
    *   `JL` (Less) 條件：`SF ≠ OF`。
    *   1 ≠ 0，條件成立 -> **會跳轉** (-16 確實小於 1)。

10. **[實體位址 - 負偏移]**
    *   JMP 指令在 `0200H`，長度 2 bytes -> `IP` 先變為 `0202H`。
    *   偏移量 `F0H` 是 8-bit 二補數 -> 代表 **-16** (十進位)。
    *   計算：`0202H - 16 (10H) = 01F2H`。
    *   結果：**01F2H**。

希望這份教學能幫你完全掌握 **選擇結構** 的底層邏輯！特別注意 **FLAGS 的變化** 和 **Jump 指令的有號/無號區分**，這是期中考後的必考題。加油！