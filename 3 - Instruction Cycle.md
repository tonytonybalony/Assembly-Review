你好！我是你的 **emu8086 組合語言家教**。

我們剛學完 emu8086 的介面操作，現在要進入計算機概論中最核心、也是 C 語言看不到的底層運作原理：**【指令與執行週期 (Instruction Cycle)】**。

這單元是期中考計算題的基礎（特別是考題 **Q2** 和 **Q23**），一定要搞懂「CPU 到底是怎麼一行一行執行程式的」。

---

### 1. 重點觀念：CPU 的心跳（Fetch-Decode-Execute）

在 C 語言中，你寫 `a = b + 1;`，編譯器把它變成了機器碼。但在 8086 CPU 眼裡，它並不是「理解」這行程式，而是機械式地不斷重複做三件事，這稱為 **機器週期 (Machine Cycle)**：

1.  **擷取 (Fetch)**：
    *   CPU 根據 **CS (Code Segment)** 和 **IP (Instruction Pointer)** 的指示，去記憶體把指令的機器碼（Machine Code）抓進來。
    *   **關鍵動作**：抓完後，**IP 會自動增加**，指向下一條指令。
2.  **解碼 (Decode)**：
    *   CPU 分析剛抓到的二進位碼（例如 `B8 05 00`），翻譯出這代表「把數值 5 放入 AX」。
3.  **執行 (Execute)**：
    *   實際執行動作（搬移資料、運算、修改旗標等）。

**期中考重點提示：**
考試很喜歡問：「執行完這行指令後，IP 變多少？」或者「下一條指令的實體位址在哪？」。
這其實就是在考你知不知道 **IP 是怎麼變化的**。

---

### 2. 相關暫存器如何被用到

在這個單元，主角只有兩個（加上一個隱形的）：

*   **CS (Code Segment)**：
    *   **程式碼段暫存器**。它定義了你的程式碼在記憶體中的「起始區塊」。
*   **IP (Instruction Pointer)**：
    *   **指令指標暫存器**。它定義了目前要執行的指令，距離程式碼段開頭的「偏移量 (Offset)」。
    *   **期中考 Q2 考點**：IP 的功能就是**指向下一個要被擷取 (Fetch) 的指令偏移位址**。
*   **IR (Instruction Register)** (隱形)：
    *   這在 emu8086 介面看不到，但在理論上，指令被 Fetch 後是暫存在這裡進行解碼。

**物理位址公式 (必考)**：
當 CPU 要抓指令時，它會計算：
$$ \text{實體位址} = (\text{CS} \times 16) + \text{IP} $$
$$ \text{Physical Address} = (\text{CS} \times 10H) + \text{IP} $$

---

### 3. 詳細解釋相關指令

為了觀察執行週期，我們使用最簡單的指令，並觀察 **機器碼長度** 對 **IP** 的影響。

#### A. NOP (No Operation)
*   **語法**：`NOP`
*   **用途**：什麼都不做，浪費一個執行週期。常用於延遲或填補記憶體空間。
*   **機器碼**：`90` (1 byte)。
*   **執行後**：`IP` 會加 **1**。

#### B. MOV (傳送) - 立即數模式
*   **語法**：`MOV AX, 1234H`
*   **用途**：把數值搬入暫存器。
*   **機器碼**：`B8 34 12` (3 bytes)。(B8是指令，34 12是數據)
*   **執行後**：`IP` 會加 **3**。

#### C. JMP (跳轉)
*   **語法**：`JMP Label`
*   **用途**：強制修改 IP 的值，跳去別的地方執行。
*   **執行後**：`IP` 會變成 Label 的位址（不是單純加長度）。

---

### 4. & 5. 範例程式碼與邏輯對照 (emu8086)

請將以下程式碼複製到 emu8086，我們用 **Single Step (單步執行)** 來觀察。

**C 語言觀念：**
```c
// C 語言看不出位址變化，它只是邏輯
int ax;
ax = 5;      // 指令長度長
nop();       // 指令長度短
goto START;  // 修改執行順序
```

**Assembly (emu8086)：**
```assembly
CODE SEGMENT
    ASSUME CS:CODE

    ; 假設程式從 Offset 0100H 開始 (COM檔預設，但在EXE檔會從0000H開始)
    ; 我們這裡觀察 EXE 模式，通常從 IP=0000H 開始

START:
    NOP             ; [位址 0000] 機器碼: 90 (長度 1 byte)
                    ; 執行後 IP 應該變 0001
    
    MOV AX, 1234H   ; [位址 0001] 機器碼: B8 34 12 (長度 3 bytes)
                    ; 執行後 IP 應該變 0001 + 3 = 0004
    
    MOV BL, 10H     ; [位址 0004] 機器碼: B3 10 (長度 2 bytes)
                    ; 執行後 IP 應該變 0004 + 2 = 0006

    JMP START       ; [位址 0006] 跳回開頭
                    ; 執行後 IP 變回 0000

CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

在 emu8086 按下 "Emulate" 後，請開啟 **View -> Memory** 視窗，並注意左邊的 **Registers** 視窗中的 **IP**。

假設 `CS = 0700H` (這個值每次執行可能不同，假設為 0700)。

| 步驟 | 執行指令 (Instruction) | 機器碼 (Machine Code) | 執行前 CS:IP | 執行動作推導 | 執行後 IP | 下一條指令實體位址 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | `NOP` | `90` | `0700:0000` | CPU 讀取 1 byte。IP = IP + 1 | **0001** | `07001H` |
| 2 | `MOV AX, 1234H` | `B8 34 12` | `0700:0001` | CPU 讀取 3 bytes (B8, 34, 12)。IP = IP + 3 | **0004** | `07004H` |
| 3 | `MOV BL, 10H` | `B3 10` | `0700:0004` | CPU 讀取 2 bytes (B3, 10)。IP = IP + 2 | **0006** | `07006H` |
| 4 | `JMP START` | `EB F8` (範例) | `0700:0006` | CPU 執行跳轉，將 IP 重設為 START 的位址 | **0000** | `07000H` |

**重要推導：**
你會發現，IP 永遠指向「**還沒執行的那一行**」。當你看到黃色光棒停在 `MOV AX, 1234H` 時，其實這行還沒做，但 IP 已經指向這裡了。一旦按下 Single Step，CPU 執行這行，IP 就會瞬間跳到下一行。

---

### 7. 初學者在 emu8086 最常犯的錯誤

1.  **手動修改 IP/CS**：
    *   錯誤：試圖寫 `MOV IP, 1000H` 或 `MOV CS, 2000H`。
    *   觀念：**CS 和 IP 是不能直接用 MOV 修改的！** 你必須透過 `JMP`、`CALL`、`RET` 這種流程控制指令來間接改變它們。
2.  **混淆實體位址與 Offset**：
    *   在回答考題時，如果問「實體位址」，一定要把 CS 乘 16 加進去。如果問「偏移位址」或「IP 的值」，就只要寫 Offset。
    *   *考題 Q11 陷阱：`MOV [0FFH], AX` 寫的是 Offset，實體位址要算 DS。*
3.  **搞錯指令長度**：
    *   8086 是 **CISC (複雜指令集)**，指令長度不固定（1~6 bytes 都有）。不要以為每行指令 IP 都是 +2。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目模仿了你的期中考題庫（特別是 Q2, Q23），請務必親自計算，不要只看答案。

**題目：**

1.  **[IP 功能]** (模仿考題 Q2) 在 8086 架構中，當 CPU 完成「擷取 (Fetch)」指令的動作後，`IP` 暫存器會自動發生什麼變化？
2.  **[實體位址計算]** (模仿考題 Q23) 已知 `CS = 2000H`，`IP = 0010H`。請計算目前 CPU 準備擷取的指令之**實體位址**。
3.  **[下一條指令]** 承上題，如果位址 `2000:0010` 處存放的指令是 `MOV AX, BX`，其機器碼長度為 2 bytes。請問執行完該指令後，`IP` 的值會變為多少？
4.  **[指令長度推算]** 若執行前 `IP = 0100H`，執行一條指令後 `IP` 變為 `0103H`。請問剛執行的這條指令長度是多少位元組？
5.  **[JMP 影響]** 執行 `JMP 0050H` 指令後，`CS` 保持不變，請問 `IP` 會變成多少？
6.  **[非法指令]** 請判斷指令 `MOV CS, AX` 是否合法？為什麼？
7.  **[執行週期]** 請排列以下 CPU 動作的正確順序：(A) 執行指令 (B) IP 指向下一條 (C) 從記憶體擷取指令 (D) 解碼指令。
8.  **[實體位址範圍]** (模仿考題 Q1) 8086 的 `CS` 和 `IP` 都是 16 位元，透過 `CS:IP` 組合出的實體位址最大可以到多少 (Hex)？這代表 8086 能定址多少記憶體空間？
9.  **[機器碼觀察]** 在 emu8086 中，`NOP` 指令的機器碼是 `90`。如果我在記憶體連續放了 5 個 `NOP`，`IP` 總共會增加多少？
10. **[綜合計算]** 已知 `CS = 1000H`。CPU 從實體位址 `10020H` 開始執行三條長度分別為 2, 3, 1 bytes 的指令。請問執行完這三條後，最後的 `IP` 值是多少 (假設起始 IP 為 0020H)？

---

### 9. 練習題詳解與推導 (做完再看！)

**1. [IP 功能]**
*   **推導**：Fetch 之後，CPU 為了準備下一次工作，必須把指標往下移。
*   **答案**：IP 會自動增加，增加的量等於剛擷取指令的長度（Bytes），指向下一條指令的偏移位址。

**2. [實體位址計算]**
*   **公式**：Physical Address = CS * 16 + IP
*   **計算**：2000H * 10H + 0010H = 20000H + 0010H
*   **答案**：**20010H**

**3. [下一條指令]**
*   **推導**：執行後 IP = 原 IP + 指令長度
*   **計算**：0010H + 2 = 0012H
*   **答案**：**0012H**

**4. [指令長度推算]**
*   **計算**：0103H - 0100H = 3
*   **答案**：**3 Bytes**

**5. [JMP 影響]**
*   **推導**：JMP 直接修改 IP 的內容。
*   **答案**：IP 變為 **0050H**。

**6. [非法指令]**
*   **答案**：**不合法**。8086 禁止直接對 `CS` (Code Segment) 進行 `MOV` 寫入操作。這會破壞程式執行的基底，非常危險。必須用 `JMP/CALL` 來改變。

**7. [執行週期]**
*   **順序**：
    1.  (C) 擷取 (Fetch)
    2.  (B) IP 指向下一條 (這步通常跟 Fetch 同時或緊接發生)
    3.  (D) 解碼 (Decode)
    4.  (A) 執行 (Execute)
*   **答案**：**C -> B -> D -> A** (註：IP更新的時間點在不同教材可能微調，但在執行前一定會更新好)。

**8. [實體位址範圍]**
*   **推導**：20條位址線 (2^20)。
*   **計算**：FFFFH:FFFFH (段+偏移的最大組合) 約等於 1MB。
*   **答案**：最大實體位址 **FFFFFH**，空間為 **1MB (1048576 Bytes)**。

**9. [機器碼觀察]**
*   **計算**：1 byte * 5 = 5 bytes。
*   **答案**：IP 增加 **5**。

**10. [綜合計算]**
*   **推導**：IP 只是單純的累加。
*   **計算**：起始 IP = 0020H。
    *   第一條後：0020H + 2 = 0022H
    *   第二條後：0022H + 3 = 0025H
    *   第三條後：0025H + 1 = 0026H
*   **答案**：**0026H**

希望這樣的一步步推導能幫你搞懂 **指令與執行週期**！這個觀念對於之後理解「為什麼 JMP 可以跳來跳去」和「為什麼 CALL 可以回來」非常重要。加油！
