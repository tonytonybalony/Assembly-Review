你好！我是你的 **emu8086 組合語言家教**。既然你是資工系學生且熟悉 C 語言，這對我們學習非常有幫助，因為組合語言其實就是把 C 語言的邏輯「拆解」成 CPU 聽得懂的最基本動作。

根據你的課程大綱，你剛學完「定址法/旗標」，現在進入「**流程控制 - 循序結構**」，這正好是期中考前的最後一個單元。這部分的重點在於**如何將單一指令組合成一段有邏輯的程式碼**，並且精確掌握每一行指令執行後，CPU 內部（暫存器、旗標、記憶體）發生了什麼事。

---

### 1. 主題觀念：什麼是「循序結構」？

在 C 語言中，除非遇到 `if`, `for`, `while`, `goto`，否則程式就是**由上往下**一行一行執行：
```c
// C 語言循序結構
int a = 10;
int b = 20;
a = a + b;
```

在 8086 組合語言中，**循序結構**的底層原理是：
1.  **CS:IP** 指向下一條要執行的指令位址。
2.  CPU 抓取（Fetch）指令。
3.  **IP (Instruction Pointer) 自動增加**，指向再下一條指令。
4.  執行（Execute）指令。
5.  回到第 1 步。

**期中考重點提示：**
考試不會只考「這行指令做什麼」，而是考「**這行指令執行後，暫存器變多少？旗標變多少？記憶體位址在哪？**」。你的考題 Q20, Q22, Q23 都在考這個邏輯。

---

### 2. 相關暫存器如何被用到

在循序結構的運算中，各個暫存器扮演不同角色：

*   **AX, BX, CX, DX (通用暫存器)**：
    *   **AX (Accumulator)**：運算中心。C 語言的 `result = a + b`，通常會先把 `a` 搬到 AX，再加 `b`。
    *   **BX (Base)**：除了存資料，最常用於**基底定址** `[BX]` (考題 Q5, Q19)。
    *   **CX (Count)**：雖主要用於迴圈，但在循序結構中常暫存變數。
    *   **DX (Data)**：常與 AX 配合處理 32 位元運算（考題 Q12）。
*   **SP, BP (堆疊與基底指標)**：
    *   **SP (Stack Pointer)**：指向堆疊頂端，執行 `PUSH`/`POP` 時會自動增減 (考題 Q4, Q16)。
    *   **BP (Base Pointer)**：用於存取堆疊中的變數，常配合 SS 段 (考題 Q24)。
*   **SI, DI (索引暫存器)**：
    *   用於陣列存取或字串處理，如 `[BX+SI]` (考題 Q21)。
*   **FLAGS (旗標)**：
    *   **最重要！** 算術指令 (`ADD`, `SUB`) 會改變旗標。
    *   **ZF (Zero)**：結果為 0 時設為 1 (考題 Q13, Q22)。
    *   **CF (Carry)**：無號數溢位 (考題 Q20)。
    *   **OF (Overflow)**：有號數溢位 (考題 Q3, Q20)。
    *   **PF (Parity)**：低 8 位元中 '1' 的個數為偶數時設為 1 (考題 Q8, Q22)。

---

### 3. & 4. 關鍵指令詳解與實作範例

我們用一個具體的任務來學習指令：**「計算 10 + 20 - 5，並將結果存入記憶體」**。

#### A. MOV (傳送指令)
*   **語法**：`MOV 目的, 來源`
*   **C 語言對照**：`dest = src;`
*   **重點**：
    *   **不影響旗標**。
    *   兩邊大小必須一致 (8-bit 對 8-bit, 16-bit 對 16-bit)。
    *   **不能**直接 `MOV [記憶體], [記憶體]` (必須透過暫存器中轉)。

#### B. ADD / SUB (算術指令)
*   **語法**：`ADD 目的, 來源` / `SUB 目的, 來源`
*   **C 語言對照**：`dest += src;` / `dest -= src;`
*   **重點**：
    *   運算結果存回「目的」。
    *   **會影響旗標 (CF, OF, ZF, SF, PF, AF)**。

#### C. INC / DEC (遞增/遞減)
*   **語法**：`INC 目的` / `DEC 目的`
*   **C 語言對照**：`dest++;` / `dest--;`
*   **重點**：
    *   **不影響 CF 旗標** (這是陷阱題常考點)。

---

### 5. & 6. 範例程式碼與邏輯推導 (emu8086)

請將以下程式碼複製到 emu8086 中執行。

**目標：** 實作 `int x = 10; int y = 20; int z = x + y - 5;`

```assembly
; 設定資料段 (Data Segment)
DATA SEGMENT
    val1 DW 10      ; 定義變數 val1 (Word, 16-bit) = 10
    val2 DW 20      ; 定義變數 val2 = 20
    ans  DW ?       ; 定義變數 ans，初始值未定
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA ; 告訴組譯器段的關聯

START:
    ; --- 步驟 1: 初始化 DS (初學者最常忘!) ---
    MOV AX, DATA    ; 將 DATA 段的位址搬入 AX
    MOV DS, AX      ; 再搬入 DS (因不支援 MOV DS, 立即數)
    
    ; 此時: DS 指向 DATA 段的起始位址

    ; --- 步驟 2: 載入資料 (C: x) ---
    MOV AX, val1    ; AX = [val1] 的值
    ; 變化: AX = 000A H (10)

    ; --- 步驟 3: 加法運算 (C: x + y) ---
    ADD AX, val2    ; AX = AX + [val2]
    ; 推導: 10 + 20 = 30
    ; 變化: AX = 001E H (30)
    ; 旗標變化: 
    ;   ZF=0 (結果不為0)
    ;   CF=0 (無進位)
    ;   OF=0 (無溢位)

    ; --- 步驟 4: 減法運算 (C: result - 5) ---
    SUB AX, 5       ; AX = AX - 5 (立即定址法)
    ; 推導: 30 - 5 = 25
    ; 變化: AX = 0019 H (25)

    ; --- 步驟 5: 存回記憶體 (C: z = ...) ---
    MOV ans, AX     ; 將結果存回 ans 變數
    ; 變化: 記憶體中 ans 的位置變成 0019 H

    ; --- 程式結束 ---
    MOV AX, 4C00H   ; DOS 功能呼叫: 結束程式
    INT 21H         ; 執行中斷
CODE ENDS
END START
```

#### 執行前後變化表 (假設)

| 步驟 | 指令 | AX (16進位) | 說明 | 旗標 (ZF/CF) |
| :--- | :--- | :--- | :--- | :--- |
| init | (啟動) | 0000 | 初始狀態 | 0 / 0 |
| 1 | `MOV AX, val1` | **000A** | 讀入 10 | 不變 |
| 2 | `ADD AX, val2` | **001E** | 10+20=30 | 0 / 0 |
| 3 | `SUB AX, 5` | **0019** | 30-5=25 | 0 / 0 |
| 4 | `MOV ans, AX` | 0019 | 寫回記憶體 | 不變 |

---

### 7. 初學者在 emu8086 最常犯的錯誤

這些錯誤如果出現在期中考的「除錯題」或「填空題」，請特別小心：

1.  **忘記初始化 DS**：
    *   錯誤：直接使用 `MOV AX, val1` 而沒有先設定 `DS`。
    *   後果：CPU 會去錯誤的記憶體區段找資料，讀到垃圾值。
2.  **記憶體對傳 (Memory to Memory)**：
    *   錯誤：`MOV [BX], [SI]` 或 `MOV var1, var2`。
    *   修正：必須透過暫存器。 `MOV AX, var2` -> `MOV var1, AX`。
3.  **運算元大小不合 (Size Mismatch)**：
    *   錯誤：`MOV AX, BL` (16位元 = 8位元，非法)。
    *   錯誤：`MOV [BX], 1` (CPU 不知道 1 是 byte 還是 word)。
    *   修正：`MOV BYTE PTR [BX], 1` 或 `MOV WORD PTR [BX], 1`。
4.  **混淆位址與數值**：
    *   `MOV AX, BX` (把 BX 的值給 AX)。
    *   `MOV AX, [BX]` (把 BX 指向的**記憶體內容**給 AX)。
    *   考題 Q5 (`MOV [BX], CX`) 就是在考這個「暫存器間接定址」。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目模仿了你的期中考題型（計算實體位址、旗標、指令邏輯），請拿紙筆計算，不要只看答案。

**題目：**

1.  **[定址法]** 已知 `DS=2000H`, `SI=0010H`。指令 `MOV AL, [SI+5]` 是什麼定址法？存取哪一個**實體位址**？
2.  **[暫存器]** 執行 `MOV AX, 1234H` 後，`AH` 的值是多少？`AL` 的值是多少？
3.  **[旗標運算]** 若 `AL=FFH` (無號數 255)，執行 `ADD AL, 1` 後，`AL` 變為多少？`ZF` (Zero Flag) 和 `CF` (Carry Flag) 分別是多少？
4.  **[堆疊計算]** 已知 `SS=5000H`, `SP=0100H`。執行 `PUSH AX` (將 2 bytes 壓入堆疊) 後，新的 `SP` 是多少？堆疊頂端的**實體位址**變為多少？
5.  **[邏輯/數學]** 寫出計算 `BX = BX + 1` 的兩種不同指令寫法。
6.  **[記憶體順序]** (模仿考題 Q17) 將 16 位元數值 `ABCDH` 存入位址 `1000H` (小端序 Little Endian)。請問 `1000H` 放什麼？`1001H` 放什麼？
7.  **[補數運算]** (模仿考題 Q10, Q18) 計算 8 位元二的補數運算：`01111111` (127) + `00000001` (1)。結果的二進位是多少？`OF` (Overflow Flag) 是 0 還是 1？
8.  **[位址計算]** (模仿考題 Q24) 已知 `SS=2000H`, `BP=1000H`, `DI=0020H`。計算指令 `MOV AX, [BP+DI+4]` 的來源運算元**實體位址**。
9.  **[指令除錯]** 判斷指令 `MOV DS, 1000H` 是否合法？如果不合法，該如何修正？
10. **[綜合追蹤]**
    ```assembly
    MOV AX, 00FFH
    ADD AL, 1
    ```
    執行完這兩行後，`AX` 的完整十六進位值是多少？

---

### 9. 練習題詳解與推導 (做完再看！)

**1. [定址法]**
*   **推導**：這是「暫存器相對定址法」(Register Relative)。
*   實體位址 = 段位址 * 10H + 偏移量
*   偏移量 (Offset) = SI + 5 = 0010H + 5 = 0015H。
*   實體位址 = 20000H + 0015H = **20015H**。

**2. [暫存器]**
*   **推導**：AX 是 16 位元，由 AH (高8位) 和 AL (低8位) 組成。
*   1234H -> 高位是 12，低位是 34。
*   **AH = 12H, AL = 34H**。

**3. [旗標運算]**
*   **推導**：FFH (1111 1111) + 1 = 1 0000 0000。
*   8 位元暫存器只能存後 8 位 -> **AL = 00H**。
*   結果為 0 -> **ZF = 1**。
*   最高位有進位 -> **CF = 1**。

**4. [堆疊計算]**
*   **推導**：堆疊是「由高位址往低位址」長。PUSH 會使 SP **減 2** (因為是 16-bit 系統)。
*   新 SP = 0100H - 2 = **00FEH**。
*   實體位址 = SS * 10H + SP = 50000H + 00FEH = **500FEH**。

**5. [邏輯/數學]**
*   方法一：`ADD BX, 1` (會影響 CF)。
*   方法二：`INC BX` (不會影響 CF)。

**6. [記憶體順序]**
*   **推導**：小端序 (Little Endian) 是「低位組放低位址」。
*   數值 `ABCDH`，低位組是 `CD`，高位組是 `AB`。
*   **1000H (低位址) = CDH**。
*   **1001H (高位址) = ABH**。

**7. [補數運算]**
*   **推導**：
    `0111 1111` (+127)
    `+ 0000 0001` (+1)
    `-----------`
    `1000 0000` (-128 in 2's complement)
*   結果二進位：**10000000**。
*   溢位判斷 (OF)：正數 + 正數 變成 負數 -> 發生溢位。
*   **OF = 1**。

**8. [位址計算]**
*   **推導**：看到 `BP`，預設段暫存器是 **SS** (非常重要的規則)。
*   偏移量 (Offset) = BP + DI + 4 = 1000H + 0020H + 4 = 1024H。
*   實體位址 = SS * 10H + Offset = 20000H + 1024H = **21024H**。

**9. [指令除錯]**
*   **推導**：`MOV` 指令不能將「立即數」直接給「段暫存器 (DS, ES, SS, CS)」。
*   **修正**：
    ```assembly
    MOV AX, 1000H
    MOV DS, AX
    ```

**10. [綜合追蹤]**
*   **推導**：這題是陷阱題。
    1. `MOV AX, 00FFH` -> AH=00, AL=FF。
    2. `ADD AL, 1` -> 只有 AL 參與運算。FF + 1 = 00 (CF=1)，但 carry **不會**自動加到 AH 去 (除非用 ADC 指令)。
    3. 此時 AL=00，AH 保持 00。
*   **AX = 0000H**。

希望這樣的講解方式能幫你把 **循序結構** 跟 **期中考觀念** 串起來！這十題如果都會算，期中考應該沒問題了。加油！