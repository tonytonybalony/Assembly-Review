你好！我是你的 **emu8086 組合語言家教**。

我們現在要進入組合語言最核心、也是期中考計算題最容易拿分（也最容易粗心掉分）的單元：**【定址法 (Addressing Modes) 與 旗標 (Flags)】**。

既然你熟悉 C 語言，我們就用 C 的觀念來破解它。

---

### 1. 重點觀念介紹

#### **A. 定址法 (Addressing Modes)**
在 C 語言中，你要存取資料有很多種寫法：
*   `int a = 10;` (直接給數值)
*   `int b = a;` (從變數拿)
*   `int *p = &a; int c = *p;` (指標取值)
*   `arr[i]` (陣列索引)

在 8086 中，**定址法**就是告訴 CPU **「資料在哪裡？」**。期中考最愛考的是**「給定暫存器數值，算出記憶體的實體位址 (Physical Address)」**。

**關鍵公式：**
$$ \text{實體位址} = (\text{段暫存器} \times 16) + \text{偏移量 (Offset)} $$
$$ \text{Physical Address} = (\text{Segment} \times 10H) + \text{Effective Address (EA)} $$

#### **B. 旗標 (Flags)**
旗標暫存器 (FLAGS) 就像是 CPU 的「健康檢查報告」。每次執行算術或邏輯運算後，CPU 會自動更新這些燈號。
*   **ZF (Zero)**: 結果是不是 0？
*   **SF (Sign)**: 結果是正還是負？
*   **CF (Carry)**: 無號數運算有沒有進位/借位？（看作**無號數溢位**）
*   **OF (Overflow)**: 有號數運算有沒有溢位？（看作**有號數溢位**）

---

### 2. 相關暫存器如何被用到

*   **資料暫存器 (BX)**：在定址法中，`BX` (Base) 是最常用的**基底**暫存器。
    *   *注意：`AX`, `CX`, `DX` 在 16-bit 模式下**不能**用來當作記憶體位址的中括號內容 `[ ]`。*
*   **指標與索引 (BP, SI, DI)**：
    *   **BP (Base Pointer)**：基底指標，**預設搭配 SS 段**（這是期中考必考陷阱）。
    *   **SI (Source Index)** / **DI (Destination Index)**：常用於陣列索引。
*   **段暫存器 (DS, SS, CS, ES)**：
    *   通常 `[BX]`, `[SI]`, `[DI]` 預設搭配 **DS**。
    *   只要看到 `[BP]`，預設搭配 **SS**。
*   **FLAGS**：存放運算狀態。

---

### 3. 詳細解釋與 C 語言對照

我們用 `MOV 目的, 來源` 來解釋資料是怎麼跑的。

| 定址法名稱 | 語法範例 (Assembly) | C 語言對照 | 用途與說明 |
| :--- | :--- | :--- | :--- |
| **立即定址** | `MOV AX, 1234H` | `ax = 0x1234;` | 資料直接寫在指令裡。 |
| **暫存器定址** | `MOV AX, BX` | `ax = bx;` | 資料在另一個暫存器。 |
| **直接定址** | `MOV AX, [1000H]` | `ax = *(int*)0x1000;` | 直接給記憶體位址（絕對位址）。 |
| **暫存器間接** | `MOV AX, [BX]` | `ax = *bx_ptr;` | 位址存在 BX 中，去那個位址拿資料。 |
| **基底相對** | `MOV AX, [BX+10H]` | `ax = *(bx_ptr + 16);` | 像存取 struct 的欄位 `ptr->field`。 |
| **基底索引** | `MOV AX, [BX+SI]` | `ax = base_ptr[index];` | 二維陣列或複雜資料結構。 |
| **相對基底索引** | `MOV AX, [BX+SI+2]` | `ax = struct_arr[i].field` | 最複雜的定址。 |

---

### 4. & 5. emu8086 範例程式碼與邏輯推導

我們來寫一段程式，模擬 C 語言的 `int arr[3] = {10, 20, 30}; int val = arr[1];`，並觀察旗標變化。

```assembly
; 設定資料段
DATA SEGMENT
    ARR DW 10H, 20H, 8000H  ; 定義陣列: 16, 32, -32768 (有號數)
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA

START:
    ; --- 1. 初始化 DS (初學者最常忘!) ---
    MOV AX, DATA    ; 假設 DATA 段位址為 0700H
    MOV DS, AX      ; DS = 0700H

    ; --- 2. 測試定址法 ---
    LEA BX, ARR     ; BX 取得 ARR 的偏移位址 (Offset)，假設是 0000H
                    ; 這行等同於 C 的: int *bx = arr;

    ; [基底相對定址] 讀取 arr[1]
    ; Word 是 2 bytes，所以 arr[1] 在 +2 的位置
    MOV AX, [BX+2]  ; AX = 20H (32)

    ; [基底索引定址] 讀取 arr[2]
    MOV SI, 4       ; 索引設為 4 (因為 arr[2] 在 offset 4)
    MOV CX, [BX+SI] ; CX = 8000H (-32768)

    ; --- 3. 測試旗標 (ADD運算) ---
    ; 測試溢位：arr[2] + arr[2]
    ; 8000H + 8000H = 10000H (65536) -> 超出 16-bit 範圍
    ADD CX, CX      
    
    ; 觀察旗標:
    ; 結果 CX = 0000H (因為 10000H 砍掉最高位)
    ; ZF = 1 (結果為0)
    ; CF = 1 (無號數進位，因為 32768+32768 > 65535)
    ; OF = 1 (有號數溢位，負數+負數變成0，邏輯錯誤)

    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

---

### 6. 程式執行前後變化表

假設 `DATA` 段位址分配在 `0700H`。

| 步驟 | 指令 | 暫存器變化 | 實體記憶體位址計算 | 旗標變化 (ZF/CF/OF) |
| :--- | :--- | :--- | :--- | :--- |
| 1 | `MOV DS, AX` | `DS` = **0700H** | - | - |
| 2 | `LEA BX, ARR` | `BX` = **0000H** | - | - |
| 3 | `MOV AX, [BX+2]` | `AX` = **0020H** | `0700H * 10H + 0000H + 2` = **07002H** | - |
| 4 | `MOV CX, [BX+SI]` | `CX` = **8000H** | `0700H * 10H + 0000H + 4` = **07004H** | - |
| 5 | `ADD CX, CX` | `CX` = **0000H** | - | **1 / 1 / 1** |

---

### 7. 初學者在 emu8086 最常犯的錯誤

1.  **非法的基底/索引暫存器**：
    *   ❌ `MOV AX, [CX]`  (錯！8086 只能用 BX, BP, SI, DI 當位址)
    *   ❌ `MOV AX, [DX]`  (錯！)
    *   ❌ `MOV AX, [AX]`  (錯！)
    *   ✅ `MOV AX, [BX]`
2.  **混用 BP 與 DS**：
    *   若題目出 `MOV AX, [BP]`，很多同學會用 `DS` 去算實體位址。
    *   **切記：看到 BP，段暫存器就要找 SS (Stack Segment)。**
3.  **不清楚 `[ ]` 的意義**：
    *   `MOV AX, 1000H` -> AX 變成 1000H。
    *   `MOV AX, [1000H]` -> AX 變成「位址 1000H 裡面的資料」。
4.  **段位址忘記左移**：
    *   計算實體位址時，段位址一定要乘以 16 (或是寫成十六進位後面補一個 0)。
    *   錯：`DS + BX`
    *   對：`DS * 10H + BX`

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目完全模仿你的期中考題型，請務必親自計算。

1.  **[實體位址計算]** 已知 `DS = 2000H`, `BX = 0100H`, `SI = 0050H`。請計算指令 `MOV AX, [BX+SI+10H]` 存取的**實體位址**。
2.  **[段暫存器規則]** 已知 `SS = 3000H`, `DS = 4000H`, `BP = 0200H`。請計算指令 `MOV CX, [BP+10H]` 存取的**實體位址**。(陷阱題)
3.  **[旗標 OF 計算]** (模仿考題 Q3, Q20) 若 `AL = 7FH` (正數 127)，執行 `ADD AL, 1` 後，`AL` 的值為多少(Hex)？`OF` 旗標是多少？為什麼？
4.  **[旗標 CF 計算]** (模仿考題 Q20) 若 `AL = FFH` (無號數 255)，執行 `ADD AL, 1` 後，`CF` 旗標是多少？
5.  **[定址法識別]** (模仿考題 Q21) 指令 `MOV AX, [BP+SI]` 屬於哪一種定址法？它預設使用哪個段暫存器？
6.  **[定址法識別]** 指令 `MOV [1234H], AX` 屬於哪一種定址法？
7.  **[合法性判斷]** 判斷指令 `MOV AX, [CX]` 在 8086 中是否合法？
8.  **[補數與旗標]** (模仿考題 Q18) 計算 4 位元二補數加法 `0111 (+7)` + `0001 (+1)`。結果是多少？是否發生溢位 (OF)？
9.  **[記憶體存取]** 已知 `[1000H]` 的值為 `34H`，`[1001H]` 的值為 `12H`。執行 `MOV AX, [1000H]` 後，`AX` 的值是多少？(注意小端序)
10. **[綜合計算]** (模仿考題 Q24) 已知 `SS=0A00H`, `BP=1000H`, `DI=0200H`。請計算 `[BP+DI+5]` 的實體位址。

---

### 9. 練習題詳解與推導 (請先自己算完再看！)

**1. [實體位址計算]**
*   公式：`DS * 10H + BX + SI + 10H`
*   計算：`20000H + 0100H + 0050H + 0010H`
*   結果：**20160H**

**2. [段暫存器規則] (陷阱題)**
*   關鍵：看到 **BP**，要用 **SS**，不是 DS。
*   公式：`SS * 10H + BP + 10H`
*   計算：`30000H + 0200H + 0010H`
*   結果：**30210H**

**3. [旗標 OF 計算]**
*   `7FH` = `0111 1111` (+127)
*   加 1 後 = `1000 0000` (`80H`)
*   在有號數系統中，`1000 0000` 是 -128。
*   正數 + 正數 變成 負數 -> **OF = 1** (發生溢位)。
*   結果 AL = **80H**。

**4. [旗標 CF 計算]**
*   `FFH` = `1111 1111` (255)
*   加 1 後 = `1 0000 0000` (256)
*   8-bit 暫存器放不下第 9 個 bit -> **CF = 1** (進位)。
*   結果 AL = 00H。

**5. [定址法識別]**
*   用了基底(BP) + 索引(SI) -> **基底索引定址法 (Base Indexed Addressing)**。
*   因為有 BP，預設段暫存器是 **SS**。

**6. [定址法識別]**
*   直接給位址數值 -> **直接定址法 (Direct Addressing)**。

**7. [合法性判斷]**
*   **不合法**。8086 的 `[ ]` 內只能是 BX, BP, SI, DI 或立即數。CX 是計數器，不能當指標。

**8. [補數與旗標]**
*   `0111` (+7) + `0001` (+1) = `1000` (-8)。
*   正 + 正 = 負 -> **溢位發生**。
*   結果 `1000`, **OF = 1**。

**9. [記憶體存取]**
*   8086 是 **Little Endian (小端序)**：低位址放低位元組。
*   低位元 (AL) = `[1000H]` = `34H`
*   高位元 (AH) = `[1001H]` = `12H`
*   AX = **1234H**。

**10. [綜合計算]**
*   因為有 BP，使用 SS。
*   `SS * 10H + BP + DI + 5`
*   `0A000H + 1000H + 0200H + 5`
*   `0A000H + 1205H`
*   結果：**0B205H**

希望這些推導過程能幫你真正理解定址法與旗標的運作！如果有任何一步卡住，歡迎隨時問我。加油！
