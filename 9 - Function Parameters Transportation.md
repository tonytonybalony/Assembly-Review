你好！我是你的 **emu8086 組合語言家教**。

我們剛學完「函式呼叫 (CALL/RET)」，你知道了 `CALL` 會把返回位址 (IP) 存入堆疊。現在我們要進入組合語言最核心、也最像 C 語言底層的部分：**【函式參數傳遞】**。

這章是期末考前的超級重點，因為它解釋了 C 語言的 `int sum(int a, int b)` 到底如何在 CPU 內部運作。

---

### 1. 重點觀念：為什麼要用堆疊傳參數？

上一章我們用暫存器 (AX, BX) 傳參數，但這有兩個大問題：
1.  **暫存器不夠用**：8086 只有 4 個通用暫存器，如果函式有 10 個參數怎麼辦？
2.  **巢狀呼叫會覆蓋**：如果 A 呼叫 B，B 又呼叫 C，大家都在用 AX，資料就會打架。

**解決方案：堆疊 (Stack)**
C 語言的標準作法是：**「把參數 PUSH 到堆疊裡，函式再去堆疊裡把它們讀出來」**。
這就會形成一個 **「堆疊框架 (Stack Frame)」**。

**期中考回顧與延伸**：
期中考考了 `[BP+DI+2H]` 這種定址法（Q24）。為什麼要用 `BP`？因為 `SP` 一直在變，我們需要一個「固定錨點」來讀取參數，那個錨點就是 **BP**。

---

### 2. 相關暫存器如何被用到

*   **SP (Stack Pointer)**：
    *   永遠指向堆疊頂端。
    *   隨著 `PUSH` 參數、`CALL` (壓入 IP)、`PUSH BP` 而不斷改變（減小）。
    *   因為它一直變，所以**不適合**用來當作讀取參數的基準點。
*   **BP (Base Pointer)**：
    *   **關鍵主角！**
    *   進入函式後，我們會把當時的 SP 抄一份給 BP (`MOV BP, SP`)。
    *   從此在函式內，BP 不會變。
    *   **參數 (Arguments)**：位於 `BP` 的 **上方** (位址較大)，如 `[BP+4]`, `[BP+6]`。
    *   **區域變數 (Local Variables)**：位於 `BP` 的 **下方** (位址較小)，如 `[BP-2]`。
*   **SS (Stack Segment)**：
    *   記住期中考 Q24：**只要用到 BP，預設段暫存器就是 SS**。

---

### 3. 詳細解釋相關指令與 Stack Frame 建立流程

標準的函式寫法（C 語言 `cdecl` 或 `stdcall` 慣例）分為三階段：

#### 階段 A：呼叫者 (Caller) 推入參數
*   **指令**：`PUSH 參數2`, `PUSH 參數1` (通常由右向左推)。
*   **指令**：`CALL Func` (這會自動 PUSH 返回位址 IP)。

#### 階段 B：被呼叫者 (Callee) 建立框架
這是制式動作，這兩行一定要背起來：
```assembly
PUSH BP      ; 1. 保存原本的 BP (因為主程式也要用 BP，不能弄壞它)
MOV BP, SP   ; 2. 設定目前的 SP 為新的錨點 (Anchor)
```
此時：
*   `[BP]` = 舊的 BP 值。
*   `[BP+2]` = 返回位址 (IP)。
*   `[BP+4]` = **參數 1**。
*   `[BP+6]` = **參數 2**。

#### 階段 C：返回與清理
*   **指令**：`POP BP` (恢復主程式的 BP)。
*   **指令**：`RET N` (返回並釋放 N bytes 的參數空間)。
    *   例如 `RET 4`：先 `POP IP`，然後 `SP = SP + 4` (把兩個參數「丟掉」)。

---

### 4. & 5. 範例程式碼與 C 語言對照

**情境：** 實作 C 語言的 `int sum(int a, int b) { return a + b; }`。

**C 語言邏輯：**
```c
void main() {
    int result = sum(10, 20); // 呼叫 sum(10, 20)
}
// 進入 sum 後，a 是 10，b 是 20
```

**Assembly (emu8086)：**
```assembly
DATA SEGMENT
    ans DW ?
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA, SS:STACK
    
START:
    MOV AX, DATA
    MOV DS, AX

    ; --- 準備呼叫 sum(10, 20) ---
    ; C 語言慣例：由右向左 PUSH
    PUSH 20         ; 參數 b (Stack: 0014H)
    PUSH 10         ; 參數 a (Stack: 000AH)
    
    CALL SUM_FUNC   ; 呼叫函式 (Stack: PUSH IP)
                    ; 此時 SP 指向返回位址
    
    ; --- 函式返回後 ---
    ; 結果在 AX 中
    MOV ans, AX     ; 存檔 (應該是 30)

    MOV AX, 4C00H
    INT 21H

; --- 函式定義 ---
SUM_FUNC PROC
    ; 1. 建立 Stack Frame (標準起手式)
    PUSH BP         ; 保存舊 BP
    MOV BP, SP      ; 讓 BP 指向當前堆疊頂端
    
    ; 此時堆疊結構：
    ; [BP]    = 舊 BP
    ; [BP+2]  = 返回位址 (IP)
    ; [BP+4]  = 參數 a (10)
    ; [BP+6]  = 參數 b (20)

    ; 2. 執行運算
    MOV AX, [BP+4]  ; 把 a (10) 放入 AX
    ADD AX, [BP+6]  ; 把 b (20) 加到 AX
    ; 結果 30 存在 AX 中，作為回傳值

    ; 3. 恢復與返回
    POP BP          ; 恢復舊 BP
    RET 4           ; 返回，並讓 SP 加 4 (丟掉兩個參數)
SUM_FUNC ENDP

CODE ENDS
END START
```

---

### 6. 程式執行前後變化與推導 (Trace)

假設 `SP` 初始為 `0100H`。我們來推導進入 `SUM_FUNC` 執行到 `MOV BP, SP` 那一瞬間的記憶體狀態。

**執行過程：**
1.  `PUSH 20` -> `SP` 變 `00FEH`，內容 `0014H`。
2.  `PUSH 10` -> `SP` 變 `00FCH`，內容 `000AH`。
3.  `CALL SUM` -> `SP` 變 `00FAH`，內容 `Next_IP` (假設 000EH)。
4.  `PUSH BP`  -> `SP` 變 `00F8H`，內容 `Old_BP`。
5.  `MOV BP, SP` -> `BP` 變 `00F8H`。

**此時的堆疊快照 (Stack Frame)：**

| 實體位址 (假設 SS=2000H) | 邏輯位址 (Offset) | 內容 (Value) | 相對 BP 的位置 | 意義 |
| :--- | :--- | :--- | :--- | :--- |
| 200FEH | 00FEH | 0014H (20) | **[BP+6]** | 參數 b |
| 200FCH | 00FCH | 000AH (10) | **[BP+4]** | 參數 a |
| 200FAH | 00FAH | 000EH (IP) | **[BP+2]** | 返回位址 |
| 200F8H | **00F8H** | xxxx (Old BP)| **[BP]** | 儲存的 BP (目前 SP/BP 在此) |

**推導 `RET 4` 的效果：**
1.  `POP BP` -> `SP` 回到 `00FAH`。
2.  `RET` (POP IP) -> `SP` 回到 `00FCH`，程式跳回主程式。
3.  `RET 4` 的額外動作 -> `SP = SP + 4` -> `SP` 回到 `0100H` (回到最原始狀態)。**堆疊平衡 (Stack Balanced)** 達成！

---

### 7. 初學者在 emu8086 最常犯的錯誤

1.  **算錯 BP 的 Offset**：
    *   很多同學以為參數是 `[BP+2]`。
    *   **錯！** `[BP+2]` 是 `CALL` 壓入的 IP。
    *   **錯！** `[BP]` 是 `PUSH BP` 壓入的舊 BP。
    *   第一個參數一定是 **`[BP+4]`** (在 16-bit 模式下)。
2.  **忘記 `RET N` 中的 N**：
    *   如果在函式裡沒有清除參數 (只寫 `RET`)，主程式的 `SP` 會卡在參數的位置。若主程式繼續 `PUSH/POP`，堆疊會越來越亂，最後 **Stack Overflow**。
3.  **搞混 Byte 和 Word**：
    *   堆疊操作 (`PUSH`/`POP`) 在 8086 永遠是以 **2 Bytes (Word)** 為單位。
    *   即使你只想傳一個字元 'A'，PUSH 進去也是佔 2 bytes。所以 Offset 永遠是 +2, +4, +6...。
4.  **忘記 `SS` 段**：
    *   計算 `[BP+4]` 的實體位址時，**一定要用 `SS`**，不要用到 `DS` (考題 Q19, Q24 陷阱)。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目完全針對你的期中考題型（位址計算、暫存器影響）設計，請務必手算。

**題目：**

1.  **[Stack Frame 結構]** 在標準函式呼叫 `PUSH BP`, `MOV BP, SP` 之後，存放「返回位址 (Return Address)」的記憶體 Offset 是 `BP` 加上多少？
2.  **[實體位址計算]** (模仿考題 Q24)
    已知 `SS = 5000H`, `BP = 0100H`。請問第一個參數 `[BP+4]` 的**實體位址**是多少？
3.  **[參數存取]** 若主程式依序執行 `PUSH AX` (值為 1), `PUSH BX` (值為 2), `CALL MY_FUNC`。在 `MY_FUNC` 裡面，`[BP+6]` 的值會是多少？
4.  **[指令影響]** 指令 `RET 6` 執行後，除了 `IP` 改變外，`SP` 暫存器的值會增加多少？
5.  **[堆疊平衡]** 為什麼函式開頭要寫 `PUSH BP`，結尾要寫 `POP BP`？如果不寫會影響到哪個暫存器？
6.  **[區域變數]** (進階) 如果我想在函式內宣告一個 16-bit 的區域變數 (Local Variable)，我應該將 `SP` 減去多少？這個變數可以用 `[BP-?]` 來存取？
7.  **[程式除錯]**
    ```assembly
    FUNC PROC
        MOV BP, SP  ; 漏了一行什麼？
        MOV AX, [BP+4]
        RET
    FUNC ENDP
    ```
    如果漏了第一行，執行完該函式後，主程式的 `BP` 會發生什麼事？
8.  **[暫存器內容]** 執行 `MOV BP, SP` 後，`SS:[BP]` (記憶體內容) 與 `SS:[SP]` 的關係為何？
9.  **[C 轉 Assembly]** 對應 C 語言 `func(10, 20, 30)`，請寫出 8086 呼叫端的 `PUSH` 順序 (由右至左) 與 `CALL` 指令。
10. **[綜合計算]** (模仿考題 Q16, Q19)
    已知 `SS=1000H`, `SP=0020H`。主程式執行 `PUSH 55H`，然後 `CALL FUNC`。
    進入 `FUNC` 並執行完 `PUSH BP` 與 `MOV BP, SP` 後。
    請問 `BP` 的值是多少？`[BP+4]` 的實體位址是多少？

---

### 9. 練習題詳解與推導

**1. [Stack Frame 結構]**
*   結構：Old_BP (at BP) -> Return IP (at BP+2).
*   答案：**BP + 2**。

**2. [實體位址計算]**
*   公式：`Physical = SS * 16 + Offset`。
*   Offset = `BP + 4` = `0100H + 4` = `0104H`。
*   Physical = `50000H + 0104H` = **50104H**。

**3. [參數存取]**
*   推入順序：PUSH 1 (Stack底), PUSH 2 (Stack頂), CALL, PUSH BP。
*   BP+4 是「最後推入的參數」 -> 2。
*   BP+6 是「最早推入的參數」 -> 1。
*   答案：**1 (AX的值)**。*(注意：參數是倒著疊上去的)*

**4. [指令影響]**
*   RET 動作：`POP IP` (SP+2)。
*   RET 6 動作：`SP + 6`。
*   總共增加：2 + 6 = **8**。
*   (或者題目單指 RET n 的 n 部分，但通常問 SP 總變化是 +8)。如果是問 RET 6 這個指令額外加多少，那是 6。但執行完該指令後 SP 比執行前增加了 8。

**5. [堆疊平衡]**
*   原因：`BP` 是 Callee-saved register。主程式可能也用 `BP` 做別的事，函式用完要把 `BP` 還原回原本的值。
*   影響：**BP** 暫存器。

**6. [區域變數]**
*   堆疊向下生長。要預留空間，需將 SP **減** 2。
*   存取位址：`[BP - 2]`。

**7. [程式除錯]**
*   漏了 `PUSH BP`。
*   `MOV BP, SP` 會直接覆蓋掉 BP 的值。
*   後果：函式返回後，主程式的 BP 變成了函式內的 SP 值（亂掉），之後主程式若再用 BP 存取變數就會出錯。

**8. [暫存器內容]**
*   `MOV BP, SP` 把 SP 的值給 BP。
*   兩者指向同一個位址，內容當然**相同**。

**9. [C 轉 Assembly]**
*   ```assembly
    PUSH 30
    PUSH 20
    PUSH 10
    CALL func
    ```

**10. [綜合計算]**
*   **Step 1: PUSH 55H** -> SP = 0020H - 2 = 001EH.
*   **Step 2: CALL** (PUSH IP) -> SP = 001EH - 2 = 001CH.
*   **Step 3: PUSH BP** -> SP = 001CH - 2 = **001AH**.
*   **Step 4: MOV BP, SP** -> BP = **001AH**.
*   **計算 [BP+4]**：
    *   BP = 001AH.
    *   Offset = 001AH + 4 = 001EH.
    *   Physical = 10000H + 001EH = **1001EH**.
    *   *(驗證：001EH 正是 Step 1 存放 55H 的位置，正確！)*

希望這章能幫你打通組合語言的「任督二脈」！這部分是銜接高階語言（C/C++）與底層硬體的關鍵。下一章我們將進入最後的 **巨集與模組化**，會輕鬆很多。把這章的題目算熟喔！