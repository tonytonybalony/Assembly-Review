你好！我是你的 **emu8086 組合語言家教**。

我們今天要進入 **【計算機結構 (Computer Architecture)】** 這個單元。這單元是了解 8086 如何運作的基礎，也是你期中考 **計算題（位址計算）** 的核心來源。

既然你懂 C 語言，我們可以把 8086 的架構想像成一個 **「硬體實作的指標系統」**。

---

### 1. 重點觀念：8086 的記憶體分段模型 (Segmentation)

8086 是一顆 **16-bit** 的微處理器，這意味著它的暫存器（Register）只能存 16 bits 的資料（最大值 $2^{16} = 65536 = 64KB$）。

但是，8086 卻有 **20條 位址線 (Address Bus)**。
*   **問題**：16-bit 的暫存器如何存取 20-bit 的記憶體位址？
    *   $2^{20} = 1,048,576$ Bytes = **1 MB** (這是期中考 Q1 的考點)。
*   **解法**：**分段 (Segmentation)**。
    *   把記憶體切成很多「段 (Segment)」。
    *   **實體位址 (Physical Address)** = **段位址 (Segment) $\times$ 16 + 偏移量 (Offset)**。
    *   在 16 進位中，乘以 16 等於 **左移一位 (補一個 0)**。

**C 語言類比**：
這就像你要找一本書裡的某一行。
*   **Segment (段)** = 「第幾章」（大概的位置）。
*   **Offset (偏移)** = 「第幾頁、第幾行」（相對於章節開頭的距離）。

---

### 2. 相關暫存器如何被用到

8086 的暫存器分為四組，每一組都在你的期中考題庫中出現過：

#### **A. 通用暫存器 (Data Registers)** - 可拆分 (考題 Q9, Q12, Q20)
這四個暫存器是 16-bit，但可以拆成「高 8 位 (High)」和「低 8 位 (Low)」獨立使用。
*   **AX (Accumulator)**: `AH`, `AL`。運算中心，乘除法必用。
*   **BX (Base)**: `BH`, `BL`。**唯一可以用來當作記憶體指標的通用暫存器**（`[BX]` 是合法的，但 `[CX]` 不行）。
*   **CX (Count)**: `CH`, `CL`。迴圈計數用。
*   **DX (Data)**: `DH`, `DL`。存資料，或與 AX 配合做大數運算。

#### **B. 段暫存器 (Segment Registers)** - 定址的基底 (考題 Q11, Q19, Q24)
*   **CS (Code Segment)**: 程式碼在哪裡。
*   **DS (Data Segment)**: 變數在哪裡。
*   **SS (Stack Segment)**: 堆疊在哪裡。
*   **ES (Extra Segment)**: 額外的資料區。

#### **C. 指標與索引暫存器 (Pointer & Index Registers)** - 定址的偏移量
*   **SP (Stack Pointer)**: 指向堆疊頂端，搭配 **SS** (考題 Q4, Q16)。
*   **BP (Base Pointer)**: 堆疊的基底，搭配 **SS** (考題 Q24)。
*   **SI (Source Index)**: 來源索引，搭配 **DS** (考題 Q6)。
*   **DI (Destination Index)**: 目的索引，搭配 **DS** (考題 Q21)。

#### **D. 控制暫存器**
*   **IP (Instruction Pointer)**: 下一道指令的偏移位址，搭配 **CS** (考題 Q2, Q23)。
*   **FLAGS**: 狀態旗標 (CF, ZF, OF, PF...) (考題 Q3, Q8, Q13, Q20, Q22)。

---

### 3. 詳細解釋相關指令

為了理解「架構」，我們不需要學複雜指令，只需專注於 **MOV** (資料搬移)，看看資料如何在暫存器與記憶體間流動。

#### **MOV 指令**
*   **語法**：`MOV 目的, 來源` (類似 C 的 `dest = src;`)
*   **用途**：將資料從「來源」複製到「目的」。
*   **常見錯誤**：
    1.  **大小不合**：`MOV AX, BL` (16-bit = 8-bit，非法)。
    2.  **記憶體對傳**：`MOV [BX], [DI]` (CPU 無法一次讀寫兩個記憶體位址)。
    3.  **段暫存器直入**：`MOV DS, 1000H` (非法！必須透過 AX 中轉)。

---

### 4. emu8086 範例程式碼

這個範例展示了「實體位址計算」與「暫存器拆分」。

```assembly
; 設定資料段的邏輯位址
DATA SEGMENT
    val1 DB 10H     ; 定義一個 byte (8-bit)
    val2 DW 1234H   ; 定義一個 word (16-bit)
DATA ENDS

CODE SEGMENT
    ASSUME CS:CODE, DS:DATA ; 告訴組譯器段的關聯

START:
    ; --- 初始化段暫存器 (架構核心觀念) ---
    ; 因為 CPU 無法直接將立即數放入 DS，必須透過 AX
    MOV AX, DATA    ; 假設 DATA 段位址是 0700H
    MOV DS, AX      ; 現在 DS = 0700H

    ; --- 暫存器拆分測試 (AX = AH + AL) ---
    MOV AX, 0       ; 清空 AX (AX=0000H)
    MOV AL, 55H     ; AX 變為 0055H
    MOV AH, 0AAH    ; AX 變為 AA55H

    ; --- 實體位址存取測試 ---
    ; 假設 BX = 0001H
    MOV BX, OFFSET val2 
    
    ; 從記憶體讀取 (DS:BX)
    ; 實體位址 = DS * 10H + BX
    MOV CX, [BX]    ; 將 val2 的值讀入 CX
                    ; 因為是 Little Endian (小端序)，
                    ; 低位組放低位址，讀出來 CX = 1234H

    ; --- 結束程式 ---
    MOV AX, 4C00H
    INT 21H
CODE ENDS
END START
```

---

### 5. 「類 C 語言」對照解釋

組合語言的記憶體存取，其實就是 C 語言的 **指標運算**。

```c
// C 語言模擬 8086 架構

// 1. 段暫存器 (Segment) 就像是記憶體的「基底指標」
char *DS_Base = (char *)0x07000; // 模擬實體位址基底

// 2. 偏移量 (Offset) 就像是陣列的「索引」
int BX_Offset = 0x0001;

// 3. 實體位址計算
// Physical_Addr = Segment * 16 + Offset
char *physical_ptr = DS_Base + BX_Offset; 

// 4. MOV CX, [BX] 的動作
// 從該指標讀取 2 bytes (因為 CX 是 16-bit)
short cx = *(short *)physical_ptr; 
```

---

### 6. 程式執行前後變化

假設 emu8086 分配 `DATA` 段在 `0700H`。

| 步驟 | 指令 | 暫存器變化 | 記憶體/實體位址變化 | 說明 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | `MOV AX, DATA` | `AX` = **0700H** | - | 準備段位址 |
| 2 | `MOV DS, AX` | `DS` = **0700H** | - | 設定資料段基底 |
| 3 | `MOV AL, 55H` | `AX` = **0055H** | - | 僅修改低 8 位 |
| 4 | `MOV AH, 0AAH`| `AX` = **AA55H** | - | 僅修改高 8 位 |
| 5 | `MOV BX, ...` | `BX` = **0001H** | - | 取得 val2 的偏移 |
| 6 | `MOV CX, [BX]`| `CX` = **1234H** | 讀取位址 **07001H** | `0700H * 10H + 0001H` |

---

### 7. 初學者最常犯的錯誤

1.  **忘記初始化 DS**：
    *   在 C 語言，全域變數可以直接用。
    *   在 8086，如果你沒做 `MOV DS, AX`，CPU 會去預設的位址（通常是亂碼或程式碼區）抓資料，導致讀到的數值是錯的。
2.  **搞混段暫存器的搭配**：
    *   用到 `BX`, `SI`, `DI` -> 預設找 `DS`。
    *   用到 `BP`, `SP` -> 預設找 `SS` (這是考題 Q24 的陷阱！)。
3.  **實體位址計算錯誤**：
    *   直接把段位址加偏移量 (`DS + BX`) 是錯的。
    *   一定要 **左移一位 (乘以 16)** 也就是 `DS * 10H + BX`。

---

### 8. 考前特訓：10 題「自己動手寫」小練習

這些題目完全模仿你的期中考題型，請拿紙筆計算，不要只看答案。

1.  **[記憶體空間]** 8086 有 20 條位址線，請問其能定址的**最大實體記憶體空間**是多少 Bytes？(請寫出計算式)
2.  **[暫存器功能]** 程式執行時，CPU 如何知道**下一條要執行的指令**在哪裡？請寫出相關的兩個暫存器名稱。
3.  **[暫存器拆分]** 已知 `AX = 1234H`。若執行 `MOV AL, 0FFH`，請問執行後 `AX` 的完整十六進位值為何？
4.  **[實體位址計算 - DS]** (模仿考題 Q11) 已知 `DS = 2000H`，偏移位址 `BX = 0500H`。請計算 `MOV AX, [BX]` 存取的**實體位址**。
5.  **[實體位址計算 - SS]** (模仿考題 Q16) 已知 `SS = 5000H`, `SP = 0100H`。請計算目前**堆疊頂端**的實體位址。
6.  **[實體位址計算 - BP]** (模仿考題 Q24) 已知 `SS = 1000H`, `DS = 2000H`, `BP = 0050H`。請計算指令 `MOV AX, [BP]` 存取的實體位址。(注意：BP 預設搭配哪個段？)
7.  **[指令合法性]** 請問指令 `MOV DS, 1000H` 是否合法？如果不合法，該如何修正？
8.  **[暫存器大小]** (模仿考題 Q6) `SI` 和 `DI` 是多少位元 (bits) 的暫存器？
9.  **[CS:IP]** (模仿考題 Q23) 已知 `CS = 0A00H`, `IP = 0020H`。CPU 目前指向的指令實體位址為何？
10. **[暫存器組合]** (模仿考題 Q12) 若 `BH = 30H`, `BL = 40H`，請問 `BX` 暫存器的值是多少？如果把這個值當作有號數 (Signed)，它是正數還是負數？

---

### 9. 練習題詳解與推導 (一定要先自己算！)

**1. [記憶體空間]**
*   **推導**：位址線 20 bits -> $2^{20}$。
*   $2^{10} = 1024 \approx 1K$。
*   $2^{20} = 1024 \times 1024 = 1,048,576$ Bytes。
*   **答案**：**1 MB** (Mega Bytes)。

**2. [暫存器功能]**
*   **推導**：指令 (Code) 放在 CS 段，偏移由 IP 決定。
*   **答案**：**CS (Code Segment)** 與 **IP (Instruction Pointer)**。

**3. [暫存器拆分]**
*   **推導**：`AX` 由 `AH` (高8位) 與 `AL` (低8位) 組成。
    *   原 `AX = 1234H` -> `AH = 12H`, `AL = 34H`。
    *   指令 `MOV AL, 0FFH` -> `AL` 變為 `FFH`。
    *   `AH` 保持不變 (`12H`)。
*   **答案**：**12FFH**。

**4. [實體位址計算 - DS]**
*   **推導**：`Physical Address = Segment * 10H + Offset`。
    *   `Segment (DS) = 2000H` -> 左移變 `20000H`。
    *   `Offset (BX) = 0500H`。
*   **計算**：`20000H + 0500H`。
*   **答案**：**20500H**。

**5. [實體位址計算 - SS]**
*   **推導**：堆疊的位址由 `SS` (Segment) 和 `SP` (Offset) 決定。
*   **計算**：`SS * 10H + SP` = `50000H + 0100H`。
*   **答案**：**50100H**。

**6. [實體位址計算 - BP] (陷阱題!)**
*   **推導**：
    *   一般 `[BX]`, `[SI]`, `[DI]` 預設搭配 `DS`。
    *   **但是！`[BP]` (Base Pointer) 預設搭配 `SS` (Stack Segment)。** 這是為了方便存取堆疊中的變數。
*   **計算**：使用 `SS` 而不是 `DS`。
    *   `10000H + 0050H`。
*   **答案**：**10050H**。

**7. [指令合法性]**
*   **推導**：8086 硬體限制，不能將立即數 (Immediate) 直接送入段暫存器。
*   **答案**：不合法。修正如下：
    ```assembly
    MOV AX, 1000H
    MOV DS, AX
    ```

**8. [暫存器大小]**
*   **推導**：8086 是 16-bit 架構，指標暫存器必須能存放 16-bit 的偏移量。
*   **答案**：**16位元 (16 bits)**。

**9. [CS:IP]**
*   **推導**：程式執行位址公式。
*   **計算**：`0A00H * 10H + 0020H` = `0A000H + 0020H`。
*   **答案**：**0A020H**。

**10. [暫存器組合]**
*   **推導**：
    *   `BX` 高位是 `BH` (30H)，低位是 `BL` (40H) -> `3040H`。
    *   判斷正負看最高位元 (MSB)。`3` 的二進位是 `0011`，最高位是 0。
*   **答案**：**3040H**，**正數**。

希望這份教學能幫你打好 8086 計算機結構的底子！記得一定要親自算過實體位址，這是期中考拿分的關鍵。如果有問題隨時問我！